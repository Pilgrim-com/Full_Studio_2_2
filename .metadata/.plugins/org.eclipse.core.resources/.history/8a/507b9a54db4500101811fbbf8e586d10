/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file           : main.c
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "motor.h"
#include "arm_math.h"
#include "QEI.h"
#include "PID.h"
#include "Kalman.h"
#include "ModBusRTU.h"
#include "math.h"
#include "Trapezoidal.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
#define PRISM_UPDATE_THRESH 40.0f
// LOW PASS cutoff frequency
#define FC   5.0f
#define VELOCITY_DEADZONE   0.01f   // ปรับตามหน่วย rads/s หรือ mm/s ที่เหมาะสม
//Joy set origin
#define RAW_MIN    0    // e.g. you saw ~20 at one end
#define RAW_CENTER 1750  // you measured ~1700–1800 at rest
#define RAW_MAX   3400   // you saw ~4080 at the other end
#define OUT_MIN  -100
#define OUT_MAX  +100
#define PATH_POINTS  (sizeof(path)/sizeof(path[0]))
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;
ADC_HandleTypeDef hadc2;
DMA_HandleTypeDef hdma_adc1;
DMA_HandleTypeDef hdma_adc2;

TIM_HandleTypeDef htim1;
TIM_HandleTypeDef htim2;
TIM_HandleTypeDef htim3;
TIM_HandleTypeDef htim4;
TIM_HandleTypeDef htim5;
TIM_HandleTypeDef htim8;
TIM_HandleTypeDef htim16;

UART_HandleTypeDef huart2;
DMA_HandleTypeDef hdma_usart2_rx;
DMA_HandleTypeDef hdma_usart2_tx;

/* USER CODE BEGIN PV */
// Velo profile
VELO_PROFILE prisProfile;
VELO_PROFILE revProfile;

ModbusHandleTypedef hmodbus;
volatile u16u8_t registerFrame[70];
//state machine
typedef enum {
	STATUS_IDLE = 0, STATUS_HOME = 1 << 0,        // 00001 = 1 - สถานะโฮมมิ่ง
	STATUS_JOG = 1 << 1,         // 00010 = 2 - สถานะจ็อกกิ้ง
	STATUS_POINT = 1 << 2,       // 00100 = 4 - สถานะเคลื่อนที่แบบจุดต่อจุด
	STATUS_GO_TO_TARGET = 1 << 3,       // 01000 = 8 - สถานะไปยังตำแหน่งเป้าหมาย
	STATUS_STOP = 1 << 4,         // 10000 = 16 - สถานะหยุดฉุกเฉิน
	STATUS_TEST = 1 << 5
} MovingStatusFlags;

typedef enum {
	STATE_IDLE,
	STATE_HOMING,
	STATE_JOGGING,
	STATE_POINT_MOVING,
	STATE_GO_TO_TARGET,
	STATE_STOPPING,
	STATE_ERROR,
	STATE_RUNING,
	STATE_PAIN,
	STATE_TEST
} RobotState;

typedef enum {
	SERVO_STATE,
} Servo_state;

RobotState current_state = STATE_IDLE;
int joy_flag = 0;
int point_flag = 0;
float joy_save[10];

MOTOR prismatic_motor;
MOTOR revolute_motor;
MOTOR servo_motor;

float target_position_prismatic = 0.0;

// PID_Velocity gain
float Kp_velo_pris = 100.0;
float Ki_velo_pris = 2.0;      //8.5;
float Kd_velo_pris = 0.0;
float output_velo_pris = 0.00;
float error_velo_pris = 0.00;

// PID_Position gain
//float Kp_pos = 4.5; encoder
float Kp_pos_pris = 6.0;
float Ki_pos_pris = 0.0;
float Kd_pos_pris = 0.0;
float output_pos_pris = 0.00;
float error_pos_pris = 0.00;

//PID_Position CMSIS
arm_pid_instance_f32 PID_POS_pris = { 0 };
arm_pid_instance_f32 PID_POS_re = { 0 };

int32_t setpoint = 0;
float output_prismatic = 0;
float output_revolute = 0;

QEI prismatic_encoder;
CONTROLLER prismatic_pos_control;
CONTROLLER prismatic_vel_control;

// Prismatic low-pass
// LOW Pass filter
const float dt = 0.001f;
const float RC = 1.0f / (2.0f * 3.1415926f * FC);
const float alpha = dt / (RC + dt);
float prismatic_radps_lowpass_prev = 0.0f;  // filter state
float prismatic_radps_lowpass = 0.0f;

// Acceleration
float prismatic_acceleration = 0.0f;
float prismatic_acceleration_lowpass = 0.0f;
float prismatic_acceleration_lowpass_prev = 0.0f;

// unit converter
double ball_screw_pos;
double ball_screw_vel;

//REvolute
float target_position_revolute = 0.0;

QEI revolute_encoder;
uint8_t revolute_flag = 0;
CONTROLLER revolute_pos_control;
CONTROLLER revolute_vel_control;

// unit converter
uint8_t limit_r = 0;
uint8_t limit_r_prev = 0;
uint8_t limit_l = 0;
uint8_t limit_l_prev = 0;
uint8_t limit_plot = 0;

float motor_voltage = 0.0;
float error_rads = 0.0;

// PID_Velocity gain
//float Kp_pos_re = 3.0;				//original 5
//float Ki_pos_re = 0.00035;         //8.5;    //8.5;
//float Kd_pos_re = 2.0;
float Kp_pos_re = 3.0;				//original 5
float Ki_pos_re = 0.00035;         //8.5;
float Kd_pos_re = 0.0;
float output_pos_re = 0.00;
float error_pos_re = 0.00;

//Revolute Velo Control
//float Kp_velo_re = 3000.0;
//float Ki_velo_re = 0.2;         //8.5;
//float Kd_velo_re = 0.0;
float Kp_velo_re = 5000.0;			//original 5000
float Ki_velo_re = 0.5;         //8.5;
float Kd_velo_re = 0.0;
float output_velo_re = 0.00;
float error_velo_re = 0.00;

//Revolute Low Pass
float revolute_radps_lowpass_prev = 0.0f;  // สถานะเก่าของความเร็วหลังกรอง
float revolute_radps_lowpass = 0.0f;  // ค่าความเร็วหลังกรองปัจจุบัน
float revolute_acceleration = 0.0f;  // เราจะคำนวณอัตราเร่ง (ดิบ)
float revolute_acceleration_lowpass_prev = 0.0f; // สถานะเก่าของอัตราเร่งหลังกรอง
float revolute_acceleration_lowpass = 0.0f;  // อัตราเร่งหลังกรอง

//Base system
uint64_t heartbeat_counter = 0;
float prev_prismatic_vel = 0.0;
float prev_prismatic_kalman_radps = 0.0;
float prev_revolute_vel = 0.0;

// Validation
uint32_t tim2_counter = 0;
uint8_t burst_mode = 0;
uint8_t flag = 0;

//JOY
uint16_t JOY_RawRead[20];
int16_t Joy_x;
int16_t Joy_y;
uint8_t Joy_run;
uint8_t Joy_save;
int count = 0.0;
int count_run = 0.0;
int count_time = 0.0;

//Proximity
uint16_t Prox_RawRead[10];
uint8_t revolute_homed = 0;

// State
uint8_t state = 0;
uint8_t button_reset = 0;
uint8_t button_reset_prev = 0;
uint8_t button_run = 0;
uint8_t waiting_state = 0;
uint8_t button_emer = 0;

//remap
float remap_pos = 0.0;
float remap_deg = 0.0;
float theta = 0.0;

uint32_t stopCounter = 0;
uint8_t pointMoveNeedsInit = 0;
uint8_t running_flang = 0;
uint8_t pain_flang = 0;
uint8_t pointRunNeedsInit = 0;
uint8_t pen_flag = 0;

static uint16_t path_idx = 0;
static uint16_t path_idx_prev = 0;
static uint8_t painInit = 1;
uint8_t count_pain = 0;
float goal_r_mm = 0.0;
float goal_th_deg = 0.0;

float ten_point[10][2] = { { 0.0, 0.0 }, { 0.0, 0.0 }, { 0.0, 0.0 },
		{ 0.0, 0.0 }, { 0.0, 0.0 }, { 0.0, 0.0 }, { 0.0, 0.0 }, { 0.0, 0.0 }, {
				0.0, 0.0 }, { 0.0, 0.0 } };
uint8_t ten_flag = 0;
uint32_t ten_count = 0;

const float path[][2] = { { -1, -1 }, { 180.35, 11.28 }, { 180.32, 15.12 }, {
		180.29, 18.96 }, { 180.26, 22.81 }, { 180.23, 26.65 },
		{ 180.20, 30.49 }, { 180.17, 34.34 }, { 180.14, 38.18 },
		{ 180.11, 42.02 }, { 180.08, 45.86 }, { 180.05, 49.71 },
		{ 180.02, 53.55 }, { 179.99, 57.39 }, { 179.96, 61.24 },
		{ 179.93, 65.08 }, { 179.91, 68.92 }, { 179.88, 72.76 },
		{ 179.85, 76.61 }, { 179.82, 80.45 }, { 179.79, 84.29 },
		{ 179.76, 88.14 }, { -1, -1 }, { 180.64, 11.57 }, { 178.92, 11.54 }, {
				177.21, 11.51 }, { 175.49, 11.48 }, { 173.77, 11.45 }, { 172.06,
				11.42 }, { 170.34, 11.39 }, { 168.63, 11.37 },
		{ 166.91, 11.34 }, { 165.19, 11.31 }, { 163.48, 11.28 },
		{ 161.76, 11.25 }, { 160.05, 11.22 }, { 158.33, 11.19 },
		{ 156.61, 11.16 }, { 154.90, 11.13 }, { 153.18, 11.10 },
		{ 151.47, 11.07 }, { 149.75, 11.04 }, { 148.03, 11.01 },
		{ 146.32, 10.98 }, { -1, -1 }, { 180.35, 33.57 }, { 178.97, 33.59 }, {
				177.59, 33.60 }, { 176.21, 33.62 }, { 174.83, 33.63 }, { 173.45,
				33.65 }, { 172.07, 33.66 }, { 170.69, 33.68 },
		{ 169.32, 33.69 }, { 167.94, 33.70 }, { 166.56, 33.72 },
		{ 165.18, 33.73 }, { 163.80, 33.75 }, { 162.42, 33.76 },
		{ 161.04, 33.78 }, { 159.66, 33.79 }, { 158.29, 33.81 },
		{ 156.91, 33.82 }, { 155.53, 33.84 }, { 154.15, 33.85 },
		{ 152.77, 33.87 }, { -1, -1 }, { 140.74, 10.40 }, { 139.67, 10.41 }, {
				138.60, 10.43 }, { 137.53, 10.44 }, { 136.46, 10.46 }, { 135.39,
				10.47 }, { 134.32, 10.49 }, { 133.25, 10.50 },
		{ 132.18, 10.51 }, { 131.11, 10.53 }, { 130.04, 10.54 },
		{ 128.97, 10.56 }, { 127.89, 10.57 }, { 126.82, 10.59 },
		{ 125.75, 10.60 }, { 124.68, 10.62 }, { 123.61, 10.63 },
		{ 122.54, 10.65 }, { 121.47, 10.66 }, { 120.40, 10.68 },
		{ 119.33, 10.69 }, { -1, -1 }, { 131.65, 10.10 }, { 131.62, 13.96 }, {
				131.59, 17.82 }, { 131.56, 21.68 }, { 131.53, 25.53 }, { 131.50,
				29.39 }, { 131.47, 33.25 }, { 131.44, 37.11 },
		{ 131.41, 40.96 }, { 131.39, 44.82 }, { 131.36, 48.68 },
		{ 131.33, 52.54 }, { 131.30, 56.40 }, { 131.27, 60.25 },
		{ 131.24, 64.11 }, { 131.21, 67.97 }, { 131.18, 71.83 },
		{ 131.15, 75.68 }, { 131.12, 79.54 }, { 131.09, 83.40 },
		{ 131.06, 87.26 }, { -1, -1 }, { 141.04, 88.43 }, { 139.97, 88.39 }, {
				138.89, 88.34 }, { 137.82, 88.30 }, { 136.75, 88.25 }, { 135.68,
				88.21 }, { 134.61, 88.16 }, { 133.54, 88.12 },
		{ 132.47, 88.08 }, { 131.40, 88.03 }, { 130.33, 87.99 },
		{ 129.26, 87.94 }, { 128.19, 87.90 }, { 127.12, 87.86 },
		{ 126.05, 87.81 }, { 124.98, 87.77 }, { 123.90, 87.72 },
		{ 122.83, 87.68 }, { 121.76, 87.64 }, { 120.69, 87.59 },
		{ 119.62, 87.55 }, { -1, -1 }, { 101.73, 89.02 }, { 101.73, 85.16 }, {
				101.73, 81.30 }, { 101.73, 77.44 }, { 101.73, 73.59 }, { 101.73,
				69.73 }, { 101.73, 65.87 }, { 101.73, 62.01 },
		{ 101.73, 58.16 }, { 101.73, 54.30 }, { 101.73, 50.44 },
		{ 101.73, 46.58 }, { 101.73, 42.72 }, { 101.73, 38.87 },
		{ 101.73, 35.01 }, { 101.73, 31.15 }, { 101.73, 27.29 },
		{ 101.73, 23.44 }, { 101.73, 19.58 }, { 101.73, 15.72 },
		{ 101.73, 11.86 }, { 101.73, 11.86 }, { 100.55, 11.86 },
		{ 99.38, 11.86 }, { 98.21, 11.86 }, { 97.03, 11.86 }, { 95.86, 11.86 },
		{ 94.69, 11.86 }, { 93.51, 11.86 }, { 92.34, 11.86 }, { 91.17, 11.86 },
		{ 89.99, 11.86 }, { 88.82, 11.86 }, { 87.65, 11.86 }, { 86.47, 11.86 },
		{ 85.30, 11.86 }, { 84.13, 11.86 }, { 82.95, 11.86 }, { 81.78, 11.86 },
		{ 80.61, 11.86 }, { 79.43, 11.86 }, { 78.26, 11.86 }, { 78.26, 11.86 },
		{ 77.50, 12.58 }, { 76.73, 13.30 }, { 75.97, 14.02 }, { 75.21, 14.74 },
		{ 74.45, 15.46 }, { 73.68, 16.18 }, { 72.92, 16.90 }, { 72.16, 17.61 },
		{ 71.39, 18.33 }, { 70.63, 19.05 }, { 69.87, 19.77 }, { 69.11, 20.49 },
		{ 68.34, 21.21 }, { 67.58, 21.93 }, { 66.82, 22.64 }, { 66.06, 23.36 },
		{ 65.29, 24.08 }, { 64.53, 24.80 }, { 63.77, 25.52 }, { 63.00, 26.24 },
		{ 63.00, 26.24 }, { 63.67, 27.06 }, { 64.33, 27.88 }, { 64.99, 28.70 },
		{ 65.65, 29.52 }, { 66.31, 30.35 }, { 66.97, 31.17 }, { 67.63, 31.99 },
		{ 68.29, 32.81 }, { 68.95, 33.63 }, { 69.61, 34.45 }, { 70.27, 35.27 },
		{ 70.93, 36.10 }, { 71.59, 36.92 }, { 72.25, 37.74 }, { 72.91, 38.56 },
		{ 73.57, 39.38 }, { 74.23, 40.20 }, { 74.89, 41.02 }, { 75.55, 41.84 },
		{ 76.21, 42.67 }, { 76.21, 42.67 }, { 77.47, 42.68 }, { 78.73, 42.70 },
		{ 79.99, 42.71 }, { 81.25, 42.72 }, { 82.51, 42.74 }, { 83.77, 42.75 },
		{ 85.04, 42.77 }, { 86.30, 42.78 }, { 87.56, 42.80 }, { 88.82, 42.81 },
		{ 90.08, 42.83 }, { 91.34, 42.84 }, { 92.60, 42.86 }, { 93.87, 42.87 },
		{ 95.13, 42.89 }, { 96.39, 42.90 }, { 97.65, 42.92 }, { 98.91, 42.93 },
		{ 100.17, 42.94 }, { 101.43, 42.96 }, { -1, -1 }, { 76.21, 42.67 }, {
				75.55, 43.40 }, { 74.89, 44.13 }, { 74.23, 44.87 }, { 73.57,
				45.60 }, { 72.91, 46.33 }, { 72.25, 47.07 }, { 71.59, 47.80 }, {
				70.93, 48.53 }, { 70.27, 49.27 }, { 69.61, 50.00 }, { 68.95,
				50.73 }, { 68.29, 51.47 }, { 67.63, 52.20 }, { 66.97, 52.93 }, {
				66.31, 53.67 }, { 65.65, 54.40 }, { 64.99, 55.13 }, { 64.33,
				55.87 }, { 63.67, 56.60 }, { 63.00, 57.33 }, { 63.00, 57.33 }, {
				63.02, 58.36 }, { 63.03, 59.39 }, { 63.05, 60.41 }, { 63.06,
				61.44 }, { 63.08, 62.47 }, { 63.09, 63.49 }, { 63.11, 64.52 }, {
				63.12, 65.55 }, { 63.14, 66.57 }, { 63.15, 67.60 }, { 63.17,
				68.63 }, { 63.18, 69.65 }, { 63.20, 70.68 }, { 63.21, 71.71 }, {
				63.22, 72.73 }, { 63.24, 73.76 }, { 63.25, 74.79 }, { 63.27,
				75.81 }, { 63.28, 76.84 }, { 63.30, 77.87 }, { 63.30, 77.87 }, {
				63.89, 78.47 }, { 64.47, 79.07 }, { 65.06, 79.67 }, { 65.65,
				80.27 }, { 66.23, 80.88 }, { 66.82, 81.48 }, { 67.41, 82.08 }, {
				67.99, 82.68 }, { 68.58, 83.28 }, { 69.17, 83.88 }, { 69.75,
				84.48 }, { 70.34, 85.08 }, { 70.93, 85.69 }, { 71.51, 86.29 }, {
				72.10, 86.89 }, { 72.69, 87.49 }, { 73.27, 88.09 }, { 73.86,
				88.69 }, { 74.45, 89.29 }, { 75.03, 89.90 }, { 75.03, 89.90 }, {
				76.41, 89.82 }, { 77.79, 89.75 }, { 79.17, 89.68 }, { 80.55,
				89.60 }, { 81.93, 89.53 }, { 83.30, 89.46 }, { 84.68, 89.38 }, {
				86.06, 89.31 }, { 87.44, 89.24 }, { 88.82, 89.16 }, { 90.20,
				89.09 }, { 91.58, 89.02 }, { 92.96, 88.94 }, { 94.33, 88.87 }, {
				95.71, 88.80 }, { 97.09, 88.72 }, { 98.47, 88.65 }, { 99.85,
				88.58 }, { 101.23, 88.50 }, { 102.61, 88.43 }, { -1, -1 }, {
				-4.17, 84.91 }, { -6.11, 84.88 }, { -8.04, 84.85 }, { -9.98,
				84.82 }, { -11.92, 84.79 }, { -13.85, 84.76 },
		{ -15.79, 84.73 }, { -17.73, 84.70 }, { -19.66, 84.67 },
		{ -21.60, 84.64 }, { -23.53, 84.62 }, { -25.47, 84.59 },
		{ -27.41, 84.56 }, { -29.34, 84.53 }, { -31.28, 84.50 },
		{ -33.21, 84.47 }, { -35.15, 84.44 }, { -37.09, 84.41 },
		{ -39.02, 84.38 }, { -40.96, 84.35 }, { -42.89, 84.32 }, { -1, -1 }, {
				-75.75, 50.59 }, { -77.42, 50.56 }, { -79.09, 50.53 }, { -80.77,
				50.50 }, { -82.44, 50.47 }, { -84.11, 50.44 },
		{ -85.78, 50.41 }, { -87.45, 50.38 }, { -89.13, 50.35 },
		{ -90.80, 50.32 }, { -92.47, 50.29 }, { -94.14, 50.26 },
		{ -95.82, 50.23 }, { -97.49, 50.21 }, { -99.16, 50.18 }, { -100.83,
				50.15 }, { -102.50, 50.12 }, { -104.18, 50.09 }, { -105.85,
				50.06 }, { -107.52, 50.03 }, { -109.19, 50.00 }, { -109.19,
				50.00 }, { -109.18, 51.04 }, { -109.16, 52.08 }, { -109.15,
				53.12 }, { -109.13, 54.17 }, { -109.12, 55.21 }, { -109.10,
				56.25 }, { -109.09, 57.29 }, { -109.07, 58.33 }, { -109.06,
				59.37 }, { -109.05, 60.41 }, { -109.03, 61.46 }, { -109.02,
				62.50 }, { -109.00, 63.54 }, { -108.99, 64.58 }, { -108.97,
				65.62 }, { -108.96, 66.66 }, { -108.94, 67.70 }, { -108.93,
				68.75 }, { -108.91, 69.79 }, { -108.90, 70.83 }, { -108.90,
				70.83 }, { -108.33, 71.52 }, { -107.75, 72.21 }, { -107.18,
				72.90 }, { -106.61, 73.59 }, { -106.04, 74.27 }, { -105.47,
				74.96 }, { -104.89, 75.65 }, { -104.32, 76.34 }, { -103.75,
				77.03 }, { -103.18, 77.72 }, { -102.61, 78.41 }, { -102.03,
				79.10 }, { -101.46, 79.79 }, { -100.89, 80.48 }, { -100.32,
				81.17 }, { -99.75, 81.86 }, { -99.17, 82.55 },
		{ -98.60, 83.24 }, { -98.03, 83.93 }, { -97.46, 84.62 },
		{ -97.46, 84.62 }, { -96.14, 84.62 }, { -94.82, 84.62 },
		{ -93.50, 84.62 }, { -92.18, 84.62 }, { -90.86, 84.62 },
		{ -89.54, 84.62 }, { -88.22, 84.62 }, { -86.90, 84.62 },
		{ -85.58, 84.62 }, { -84.26, 84.62 }, { -82.94, 84.62 },
		{ -81.62, 84.62 }, { -80.30, 84.62 }, { -78.98, 84.62 },
		{ -77.66, 84.62 }, { -76.34, 84.62 }, { -75.02, 84.62 },
		{ -73.70, 84.62 }, { -72.38, 84.62 }, { -71.06, 84.62 },
		{ -71.06, 84.62 }, { -70.13, 83.87 }, { -69.21, 83.12 },
		{ -68.28, 82.37 }, { -67.36, 81.62 }, { -66.44, 80.88 },
		{ -65.51, 80.13 }, { -64.59, 79.38 }, { -63.66, 78.63 },
		{ -62.74, 77.88 }, { -61.82, 77.13 }, { -60.89, 76.39 },
		{ -59.97, 75.64 }, { -59.04, 74.89 }, { -58.12, 74.14 },
		{ -57.20, 73.39 }, { -56.27, 72.65 }, { -55.35, 71.90 },
		{ -54.42, 71.15 }, { -53.50, 70.40 }, { -52.58, 69.65 },
		{ -52.58, 69.65 }, { -52.56, 67.85 }, { -52.55, 66.05 },
		{ -52.53, 64.24 }, { -52.52, 62.44 }, { -52.50, 60.63 },
		{ -52.49, 58.83 }, { -52.47, 57.03 }, { -52.46, 55.22 },
		{ -52.44, 53.42 }, { -52.43, 51.61 }, { -52.41, 49.81 },
		{ -52.40, 48.01 }, { -52.38, 46.20 }, { -52.37, 44.40 },
		{ -52.36, 42.59 }, { -52.34, 40.79 }, { -52.33, 38.98 },
		{ -52.31, 37.18 }, { -52.30, 35.38 }, { -52.28, 33.57 },
		{ -52.28, 33.57 }, { -52.93, 32.49 }, { -53.57, 31.40 },
		{ -54.22, 30.32 }, { -54.86, 29.23 }, { -55.51, 28.15 },
		{ -56.15, 27.06 }, { -56.80, 25.97 }, { -57.45, 24.89 },
		{ -58.09, 23.80 }, { -58.74, 22.72 }, { -59.38, 21.63 },
		{ -60.03, 20.55 }, { -60.67, 19.46 }, { -61.32, 18.38 },
		{ -61.96, 17.29 }, { -62.61, 16.21 }, { -63.25, 15.12 },
		{ -63.90, 14.04 }, { -64.54, 12.95 }, { -65.19, 11.86 },
		{ -65.19, 11.86 }, { -66.69, 11.86 }, { -68.18, 11.86 },
		{ -69.68, 11.86 }, { -71.17, 11.86 }, { -72.67, 11.86 },
		{ -74.17, 11.86 }, { -75.66, 11.86 }, { -77.16, 11.86 },
		{ -78.65, 11.86 }, { -80.15, 11.86 }, { -81.65, 11.86 },
		{ -83.14, 11.86 }, { -84.64, 11.86 }, { -86.13, 11.86 },
		{ -87.63, 11.86 }, { -89.13, 11.86 }, { -90.62, 11.86 },
		{ -92.12, 11.86 }, { -93.62, 11.86 }, { -95.11, 11.86 },
		{ -95.11, 11.86 }, { -95.77, 12.39 }, { -96.43, 12.92 },
		{ -97.09, 13.45 }, { -97.75, 13.98 }, { -98.41, 14.50 },
		{ -99.07, 15.03 }, { -99.73, 15.56 }, { -100.39, 16.09 }, { -101.05,
				16.62 }, { -101.71, 17.14 }, { -102.37, 17.67 }, { -103.03,
				18.20 }, { -103.69, 18.73 }, { -104.35, 19.26 }, { -105.01,
				19.78 }, { -105.67, 20.31 }, { -106.33, 20.84 }, { -106.99,
				21.37 }, { -107.65, 21.90 }, { -108.31, 22.42 }, { -1, -1 }, {
				-174.61, 11.86 }, { -175.97, 11.89 }, { -177.34, 11.92 }, {
				-178.70, 11.95 }, { -180.07, 11.98 }, { -181.43, 12.01 }, {
				-182.79, 12.04 }, { -184.16, 12.07 }, { -185.52, 12.10 }, {
				-186.89, 12.13 }, { -188.25, 12.16 }, { -189.61, 12.19 }, {
				-190.98, 12.22 }, { -192.34, 12.25 }, { -193.71, 12.28 }, {
				-195.07, 12.30 }, { -196.43, 12.33 }, { -197.80, 12.36 }, {
				-199.16, 12.39 }, { -200.53, 12.42 }, { -201.89, 12.45 }, {
				-201.89, 12.45 }, { -202.79, 13.17 }, { -203.68, 13.89 }, {
				-204.58, 14.61 }, { -205.47, 15.33 }, { -206.36, 16.04 }, {
				-207.26, 16.76 }, { -208.15, 17.48 }, { -209.05, 18.20 }, {
				-209.94, 18.92 }, { -210.84, 19.64 }, { -211.73, 20.36 }, {
				-212.63, 21.08 }, { -213.52, 21.79 }, { -214.42, 22.51 }, {
				-215.31, 23.23 }, { -216.21, 23.95 }, { -217.10, 24.67 }, {
				-218.00, 25.39 }, { -218.89, 26.11 }, { -219.79, 26.83 }, {
				-219.79, 26.83 }, { -218.83, 27.76 }, { -217.88, 28.70 }, {
				-216.93, 29.64 }, { -215.97, 30.58 }, { -215.02, 31.52 }, {
				-214.07, 32.46 }, { -213.11, 33.40 }, { -212.16, 34.34 }, {
				-211.21, 35.27 }, { -210.25, 36.21 }, { -209.30, 37.15 }, {
				-208.34, 38.09 }, { -207.39, 39.03 }, { -206.44, 39.97 }, {
				-205.48, 40.91 }, { -204.53, 41.84 }, { -203.58, 42.78 }, {
				-202.62, 43.72 }, { -201.67, 44.66 }, { -200.72, 45.60 }, {
				-200.72, 45.60 }, { -199.65, 45.61 }, { -198.58, 45.63 }, {
				-197.51, 45.64 }, { -196.43, 45.66 }, { -195.36, 45.67 }, {
				-194.29, 45.69 }, { -193.22, 45.70 }, { -192.15, 45.72 }, {
				-191.08, 45.73 }, { -190.01, 45.75 }, { -188.94, 45.76 }, {
				-187.87, 45.78 }, { -186.80, 45.79 }, { -185.73, 45.81 }, {
				-184.66, 45.82 }, { -183.59, 45.83 }, { -182.52, 45.85 }, {
				-181.44, 45.86 }, { -180.37, 45.88 }, { -179.30, 45.89 }, { -1,
				-1 }, { -199.84, 45.89 }, { -200.67, 46.41 },
		{ -201.51, 46.92 }, { -202.35, 47.43 }, { -203.18, 47.95 }, { -204.02,
				48.46 }, { -204.85, 48.97 }, { -205.69, 49.49 }, { -206.53,
				50.00 }, { -207.36, 50.51 }, { -208.20, 51.03 }, { -209.03,
				51.54 }, { -209.87, 52.05 }, { -210.71, 52.57 }, { -211.54,
				53.08 }, { -212.38, 53.59 }, { -213.21, 54.11 }, { -214.05,
				54.62 }, { -214.89, 55.13 }, { -215.72, 55.65 }, { -216.56,
				56.16 }, { -216.56, 56.16 }, { -216.54, 56.98 }, { -216.53,
				57.80 }, { -216.51, 58.62 }, { -216.50, 59.45 }, { -216.49,
				60.27 }, { -216.47, 61.09 }, { -216.46, 61.91 }, { -216.44,
				62.73 }, { -216.43, 63.55 }, { -216.41, 64.37 }, { -216.40,
				65.20 }, { -216.38, 66.02 }, { -216.37, 66.84 }, { -216.35,
				67.66 }, { -216.34, 68.48 }, { -216.32, 69.30 }, { -216.31,
				70.12 }, { -216.29, 70.95 }, { -216.28, 71.77 }, { -216.27,
				72.59 }, { -216.27, 72.59 }, { -215.46, 73.00 }, { -214.65,
				73.41 }, { -213.85, 73.82 }, { -213.04, 74.23 }, { -212.23,
				74.64 }, { -211.43, 75.05 }, { -210.62, 75.46 }, { -209.81,
				75.87 }, { -209.00, 76.28 }, { -208.20, 76.69 }, { -207.39,
				77.11 }, { -206.58, 77.52 }, { -205.78, 77.93 }, { -204.97,
				78.34 }, { -204.16, 78.75 }, { -203.36, 79.16 }, { -202.55,
				79.57 }, { -201.74, 79.98 }, { -200.94, 80.39 }, { -200.13,
				80.80 }, { -200.13, 80.80 }, { -198.94, 80.77 }, { -197.75,
				80.74 }, { -196.57, 80.71 }, { -195.38, 80.68 }, { -194.19,
				80.66 }, { -193.00, 80.63 }, { -191.81, 80.60 }, { -190.63,
				80.57 }, { -189.44, 80.54 }, { -188.25, 80.51 }, { -187.06,
				80.48 }, { -185.87, 80.45 }, { -184.69, 80.42 }, { -183.50,
				80.39 }, { -182.31, 80.36 }, { -181.12, 80.33 }, { -179.93,
				80.30 }, { -178.75, 80.27 }, { -177.56, 80.24 }, { -176.37,
				80.22 }, { -1, -1 }, { 32.50, 13.04 }, { 33.34, 13.96 }, {
				34.17, 14.88 }, { 35.01, 15.81 }, { 35.84, 16.73 }, { 36.68,
				17.66 }, { 37.52, 18.58 }, { 38.35, 19.50 }, { 39.19, 20.43 }, {
				40.02, 21.35 }, { 40.86, 22.28 }, { 41.70, 23.20 }, { 42.53,
				24.12 }, { 43.37, 25.05 }, { 44.20, 25.97 }, { 45.04, 26.90 }, {
				45.88, 27.82 }, { 46.71, 28.75 }, { 47.55, 29.67 }, { 48.38,
				30.59 }, { 49.22, 31.52 }, { 49.22, 31.52 }, { 49.26, 33.28 }, {
				49.31, 35.04 }, { 49.35, 36.80 }, { 49.40, 38.56 }, { 49.44,
				40.32 }, { 49.48, 42.08 }, { 49.53, 43.84 }, { 49.57, 45.60 }, {
				49.62, 47.36 }, { 49.66, 49.12 }, { 49.70, 50.88 }, { 49.75,
				52.64 }, { 49.79, 54.40 }, { 49.84, 56.16 }, { 49.88, 57.92 }, {
				49.92, 59.68 }, { 49.97, 61.44 }, { 50.01, 63.20 }, { 50.06,
				64.96 }, { 50.10, 66.72 }, { 50.10, 66.72 }, { 49.34, 67.70 }, {
				48.58, 68.68 }, { 47.81, 69.67 }, { 47.05, 70.65 }, { 46.29,
				71.63 }, { 45.52, 72.62 }, { 44.76, 73.60 }, { 44.00, 74.58 }, {
				43.24, 75.56 }, { 42.47, 76.55 }, { 41.71, 77.53 }, { 40.95,
				78.51 }, { 40.19, 79.49 }, { 39.42, 80.48 }, { 38.66, 81.46 }, {
				37.90, 82.44 }, { 37.13, 83.43 }, { 36.37, 84.41 }, { 35.61,
				85.39 }, { 34.85, 86.37 }, { 34.85, 86.37 }, { 34.04, 85.58 }, {
				33.23, 84.79 }, { 32.43, 84.00 }, { 31.62, 83.21 }, { 30.81,
				82.41 }, { 30.01, 81.62 }, { 29.20, 80.83 }, { 28.39, 80.04 }, {
				27.59, 79.25 }, { 26.78, 78.45 }, { 25.97, 77.66 }, { 25.17,
				76.87 }, { 24.36, 76.08 }, { 23.55, 75.29 }, { 22.75, 74.49 }, {
				21.94, 73.70 }, { 21.13, 72.91 }, { 20.33, 72.12 }, { 19.52,
				71.33 }, { 18.71, 70.53 }, { 18.71, 70.53 }, { 18.68, 68.54 }, {
				18.65, 66.54 }, { 18.62, 64.55 }, { 18.60, 62.55 }, { 18.57,
				60.56 }, { 18.54, 58.56 }, { 18.51, 56.57 }, { 18.48, 54.57 }, {
				18.45, 52.58 }, { 18.42, 50.59 }, { 18.39, 48.59 }, { 18.36,
				46.60 }, { 18.33, 44.60 }, { 18.30, 42.61 }, { 18.27, 40.61 }, {
				18.24, 38.62 }, { 18.21, 36.62 }, { 18.18, 34.63 }, { 18.16,
				32.63 }, { 18.13, 30.64 }, { 18.13, 30.64 }, { 18.84, 29.76 }, {
				19.56, 28.88 }, { 20.28, 28.00 }, { 21.00, 27.12 }, { 21.72,
				26.24 }, { 22.44, 25.36 }, { 23.16, 24.48 }, { 23.88, 23.60 }, {
				24.59, 22.72 }, { 25.31, 21.84 }, { 26.03, 20.96 }, { 26.75,
				20.08 }, { 27.47, 19.20 }, { 28.19, 18.32 }, { 28.91, 17.44 }, {
				29.63, 16.56 }, { 30.34, 15.68 }, { 31.06, 14.80 }, { 31.78,
				13.92 }, { 32.50, 13.04 }, { -1, -1 }, { -160.82, 24.18 }, {
				-160.83, 26.97 }, { -160.85, 29.76 }, { -160.86, 32.54 }, {
				-160.88, 35.33 }, { -160.89, 38.12 }, { -160.91, 40.90 }, {
				-160.92, 43.69 }, { -160.94, 46.48 }, { -160.95, 49.27 }, {
				-160.97, 52.05 }, { -160.98, 54.84 }, { -160.99, 57.63 }, {
				-161.01, 60.41 }, { -161.02, 63.20 }, { -161.04, 65.99 }, {
				-161.05, 68.77 }, { -161.07, 71.56 }, { -161.08, 74.35 }, {
				-161.10, 77.13 }, { -161.11, 79.92 }, { -161.11, 79.92 }, {
				-160.14, 80.33 }, { -159.18, 80.74 }, { -158.21, 81.15 }, {
				-157.24, 81.56 }, { -156.27, 81.97 }, { -155.30, 82.38 }, {
				-154.34, 82.80 }, { -153.37, 83.21 }, { -152.40, 83.62 }, {
				-151.43, 84.03 }, { -150.46, 84.44 }, { -149.50, 84.85 }, {
				-148.53, 85.26 }, { -147.56, 85.67 }, { -146.59, 86.08 }, {
				-145.62, 86.49 }, { -144.65, 86.90 }, { -143.69, 87.31 }, {
				-142.72, 87.72 }, { -141.75, 88.13 }, { -141.75, 88.13 }, {
				-140.71, 87.28 }, { -139.67, 86.43 }, { -138.63, 85.58 }, {
				-137.59, 84.73 }, { -136.54, 83.88 }, { -135.50, 83.03 }, {
				-134.46, 82.18 }, { -133.42, 81.33 }, { -132.38, 80.48 }, {
				-131.34, 79.63 }, { -130.30, 78.78 }, { -129.25, 77.93 }, {
				-128.21, 77.07 }, { -127.17, 76.22 }, { -126.13, 75.37 }, {
				-125.09, 74.52 }, { -124.05, 73.67 }, { -123.01, 72.82 }, {
				-121.96, 71.97 }, { -120.92, 71.12 }, { -120.92, 71.12 }, {
				-120.92, 68.82 }, { -120.92, 66.51 }, { -120.92, 64.21 }, {
				-120.92, 61.91 }, { -120.92, 59.61 }, { -120.92, 57.30 }, {
				-120.92, 55.00 }, { -120.92, 52.70 }, { -120.92, 50.39 }, {
				-120.92, 48.09 }, { -120.92, 45.79 }, { -120.92, 43.49 }, {
				-120.92, 41.18 }, { -120.92, 38.88 }, { -120.92, 36.58 }, {
				-120.92, 34.27 }, { -120.92, 31.97 }, { -120.92, 29.67 }, {
				-120.92, 27.37 }, { -120.92, 25.06 }, { -120.92, 25.06 }, {
				-121.86, 24.40 }, { -122.80, 23.74 }, { -123.74, 23.08 }, {
				-124.68, 22.42 }, { -125.62, 21.76 }, { -126.56, 21.10 }, {
				-127.49, 20.44 }, { -128.43, 19.78 }, { -129.37, 19.12 }, {
				-130.31, 18.46 }, { -131.25, 17.80 }, { -132.19, 17.14 }, {
				-133.13, 16.48 }, { -134.06, 15.82 }, { -135.00, 15.16 }, {
				-135.94, 14.50 }, { -136.88, 13.84 }, { -137.82, 13.18 }, {
				-138.76, 12.52 }, { -139.70, 11.86 }, { -139.70, 11.86 }, {
				-140.75, 12.48 }, { -141.81, 13.09 }, { -142.87, 13.71 }, {
				-143.92, 14.33 }, { -144.98, 14.94 }, { -146.03, 15.56 }, {
				-147.09, 16.18 }, { -148.15, 16.79 }, { -149.20, 17.41 }, {
				-150.26, 18.02 }, { -151.31, 18.64 }, { -152.37, 19.26 }, {
				-153.43, 19.87 }, { -154.48, 20.49 }, { -155.54, 21.10 }, {
				-156.59, 21.72 }, { -157.65, 22.34 }, { -158.71, 22.95 }, {
				-159.76, 23.57 }, { -160.82, 24.18 }, { -1, -1 }, };

uint8_t button_run_prev = 0;
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_TIM1_Init(void);
static void MX_TIM2_Init(void);
static void MX_TIM4_Init(void);
static void MX_TIM5_Init(void);
static void MX_TIM3_Init(void);
static void MX_ADC1_Init(void);
static void MX_TIM16_Init(void);
static void MX_USART2_UART_Init(void);
static void MX_ADC2_Init(void);
static void MX_TIM8_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
 * @brief  The application entry point.
 * @retval int
 */
int main(void) {

	/* USER CODE BEGIN 1 */

	/* USER CODE END 1 */

	/* MCU Configuration--------------------------------------------------------*/

	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();

	/* USER CODE BEGIN Init */

	/* USER CODE END Init */

	/* Configure the system clock */
	SystemClock_Config();

	/* USER CODE BEGIN SysInit */

	/* USER CODE END SysInit */

	/* Initialize all configured peripherals */
	MX_GPIO_Init();
	MX_DMA_Init();
	MX_TIM1_Init();
	MX_TIM2_Init();
	MX_TIM4_Init();
	MX_TIM5_Init();
	MX_TIM3_Init();
	MX_ADC1_Init();
	MX_TIM16_Init();
	MX_USART2_UART_Init();
	MX_ADC2_Init();
	MX_TIM8_Init();
	/* USER CODE BEGIN 2 */
	hmodbus.huart = &huart2;
	hmodbus.htim = &htim16;
	hmodbus.slaveAddress = 0x15;
	hmodbus.RegisterSize = 70;
	Modbus_init(&hmodbus, &registerFrame);

	PID_POS_pris.Kp = Kp_pos_pris;
	PID_POS_pris.Ki = Ki_pos_pris;
	PID_POS_pris.Kd = Kd_pos_pris;
	arm_pid_init_f32(&PID_POS_pris, 0);

	PID_POS_re.Kp = Kp_pos_re;
	PID_POS_re.Ki = Ki_pos_re;
	PID_POS_re.Kd = Kd_pos_re;
	arm_pid_init_f32(&PID_POS_re, 0);

	MotorInit(&prismatic_motor, &htim1, TIM_CHANNEL_3, GPIOC, GPIO_PIN_7);
	MotorInit(&revolute_motor, &htim1, TIM_CHANNEL_2, GPIOC, GPIO_PIN_6);
	HAL_TIM_Base_Start(&htim8);
	HAL_TIM_PWM_Start(&htim8, TIM_CHANNEL_1);

	QEIInit(&prismatic_encoder, &htim4, 8192, 1000, 65536);
	QEIInit(&revolute_encoder, &htim3, 8192, 1000, 65536);

	PIDInit(&prismatic_vel_control, 65535, -65535);
	PIDInit(&revolute_vel_control, 65535, -65535);

	HAL_TIM_Base_Start_IT(&htim5);
	HAL_TIM_Base_Start_IT(&htim2);

	HAL_ADC_Start_DMA(&hadc1, JOY_RawRead, 20);
	HAL_ADC_Start_DMA(&hadc2, Prox_RawRead, 10);

//	MotorInit(&revolute_motor, &htim1, TIM_CHANNEL_1, GPIOB, GPIO_PIN_0);

//	registerFrame[4].U16 = 1;
//	registerFrame[5].U16 = 0;
	/* USER CODE END 2 */

	/* Infinite loop */
	/* USER CODE BEGIN WHILE */
	while (1) {
		/* USER CODE END WHILE */

		/* USER CODE BEGIN 3 */
		Modbus_Protocal_Worker();
	}
	/* USER CODE END 3 */
}

/**
 * @brief System Clock Configuration
 * @retval None
 */
void SystemClock_Config(void) {
	RCC_OscInitTypeDef RCC_OscInitStruct = { 0 };
	RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 };

	/** Configure the main internal regulator output voltage
	 */
	HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST);

	/** Initializes the RCC Oscillators according to the specified parameters
	 * in the RCC_OscInitTypeDef structure.
	 */
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
	RCC_OscInitStruct.HSIState = RCC_HSI_ON;
	RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
	RCC_OscInitStruct.PLL.PLLM = RCC_PLLM_DIV4;
	RCC_OscInitStruct.PLL.PLLN = 85;
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
	RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
	RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
		Error_Handler();
	}

	/** Initializes the CPU, AHB and APB buses clocks
	 */
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK
			| RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK) {
		Error_Handler();
	}
}

/**
 * @brief ADC1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_ADC1_Init(void) {

	/* USER CODE BEGIN ADC1_Init 0 */

	/* USER CODE END ADC1_Init 0 */

	ADC_MultiModeTypeDef multimode = { 0 };
	ADC_ChannelConfTypeDef sConfig = { 0 };

	/* USER CODE BEGIN ADC1_Init 1 */

	/* USER CODE END ADC1_Init 1 */

	/** Common config
	 */
	hadc1.Instance = ADC1;
	hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
	hadc1.Init.Resolution = ADC_RESOLUTION_12B;
	hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
	hadc1.Init.GainCompensation = 0;
	hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
	hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
	hadc1.Init.LowPowerAutoWait = DISABLE;
	hadc1.Init.ContinuousConvMode = ENABLE;
	hadc1.Init.NbrOfConversion = 2;
	hadc1.Init.DiscontinuousConvMode = DISABLE;
	hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
	hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
	hadc1.Init.DMAContinuousRequests = ENABLE;
	hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
	hadc1.Init.OversamplingMode = DISABLE;
	if (HAL_ADC_Init(&hadc1) != HAL_OK) {
		Error_Handler();
	}

	/** Configure the ADC multi-mode
	 */
	multimode.Mode = ADC_MODE_INDEPENDENT;
	if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK) {
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_7;
	sConfig.Rank = ADC_REGULAR_RANK_1;
	sConfig.SamplingTime = ADC_SAMPLETIME_640CYCLES_5;
	sConfig.SingleDiff = ADC_SINGLE_ENDED;
	sConfig.OffsetNumber = ADC_OFFSET_NONE;
	sConfig.Offset = 0;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK) {
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_8;
	sConfig.Rank = ADC_REGULAR_RANK_2;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN ADC1_Init 2 */

	/* USER CODE END ADC1_Init 2 */

}

/**
 * @brief ADC2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_ADC2_Init(void) {

	/* USER CODE BEGIN ADC2_Init 0 */

	/* USER CODE END ADC2_Init 0 */

	ADC_ChannelConfTypeDef sConfig = { 0 };

	/* USER CODE BEGIN ADC2_Init 1 */

	/* USER CODE END ADC2_Init 1 */

	/** Common config
	 */
	hadc2.Instance = ADC2;
	hadc2.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
	hadc2.Init.Resolution = ADC_RESOLUTION_12B;
	hadc2.Init.DataAlign = ADC_DATAALIGN_RIGHT;
	hadc2.Init.GainCompensation = 0;
	hadc2.Init.ScanConvMode = ADC_SCAN_DISABLE;
	hadc2.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
	hadc2.Init.LowPowerAutoWait = DISABLE;
	hadc2.Init.ContinuousConvMode = ENABLE;
	hadc2.Init.NbrOfConversion = 1;
	hadc2.Init.DiscontinuousConvMode = DISABLE;
	hadc2.Init.ExternalTrigConv = ADC_SOFTWARE_START;
	hadc2.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
	hadc2.Init.DMAContinuousRequests = ENABLE;
	hadc2.Init.Overrun = ADC_OVR_DATA_PRESERVED;
	hadc2.Init.OversamplingMode = DISABLE;
	if (HAL_ADC_Init(&hadc2) != HAL_OK) {
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_6;
	sConfig.Rank = ADC_REGULAR_RANK_1;
	sConfig.SamplingTime = ADC_SAMPLETIME_640CYCLES_5;
	sConfig.SingleDiff = ADC_SINGLE_ENDED;
	sConfig.OffsetNumber = ADC_OFFSET_NONE;
	sConfig.Offset = 0;
	if (HAL_ADC_ConfigChannel(&hadc2, &sConfig) != HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN ADC2_Init 2 */

	/* USER CODE END ADC2_Init 2 */

}

/**
 * @brief TIM1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM1_Init(void) {

	/* USER CODE BEGIN TIM1_Init 0 */

	/* USER CODE END TIM1_Init 0 */

	TIM_ClockConfigTypeDef sClockSourceConfig = { 0 };
	TIM_MasterConfigTypeDef sMasterConfig = { 0 };
	TIM_OC_InitTypeDef sConfigOC = { 0 };
	TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = { 0 };

	/* USER CODE BEGIN TIM1_Init 1 */

	/* USER CODE END TIM1_Init 1 */
	htim1.Instance = TIM1;
	htim1.Init.Prescaler = 169;
	htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim1.Init.Period = 19999;
	htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim1.Init.RepetitionCounter = 0;
	htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim1) != HAL_OK) {
		Error_Handler();
	}
	sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
	if (HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig) != HAL_OK) {
		Error_Handler();
	}
	if (HAL_TIM_PWM_Init(&htim1) != HAL_OK) {
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig)
			!= HAL_OK) {
		Error_Handler();
	}
	sConfigOC.OCMode = TIM_OCMODE_PWM1;
	sConfigOC.Pulse = 0;
	sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
	sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
	sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
	sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
	sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
	if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_2)
			!= HAL_OK) {
		Error_Handler();
	}
	if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_3)
			!= HAL_OK) {
		Error_Handler();
	}
	sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
	sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
	sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
	sBreakDeadTimeConfig.DeadTime = 0;
	sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
	sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
	sBreakDeadTimeConfig.BreakFilter = 0;
	sBreakDeadTimeConfig.BreakAFMode = TIM_BREAK_AFMODE_INPUT;
	sBreakDeadTimeConfig.Break2State = TIM_BREAK2_DISABLE;
	sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
	sBreakDeadTimeConfig.Break2Filter = 0;
	sBreakDeadTimeConfig.Break2AFMode = TIM_BREAK_AFMODE_INPUT;
	sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
	if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig)
			!= HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN TIM1_Init 2 */

	/* USER CODE END TIM1_Init 2 */
	HAL_TIM_MspPostInit(&htim1);

}

/**
 * @brief TIM2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM2_Init(void) {

	/* USER CODE BEGIN TIM2_Init 0 */

	/* USER CODE END TIM2_Init 0 */

	TIM_ClockConfigTypeDef sClockSourceConfig = { 0 };
	TIM_MasterConfigTypeDef sMasterConfig = { 0 };

	/* USER CODE BEGIN TIM2_Init 1 */

	/* USER CODE END TIM2_Init 1 */
	htim2.Instance = TIM2;
	htim2.Init.Prescaler = 169;
	htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim2.Init.Period = 999;
	htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim2) != HAL_OK) {
		Error_Handler();
	}
	sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
	if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK) {
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig)
			!= HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN TIM2_Init 2 */

	/* USER CODE END TIM2_Init 2 */

}

/**
 * @brief TIM3 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM3_Init(void) {

	/* USER CODE BEGIN TIM3_Init 0 */

	/* USER CODE END TIM3_Init 0 */

	TIM_Encoder_InitTypeDef sConfig = { 0 };
	TIM_MasterConfigTypeDef sMasterConfig = { 0 };

	/* USER CODE BEGIN TIM3_Init 1 */

	/* USER CODE END TIM3_Init 1 */
	htim3.Instance = TIM3;
	htim3.Init.Prescaler = 0;
	htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim3.Init.Period = 65535;
	htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	sConfig.EncoderMode = TIM_ENCODERMODE_TI12;
	sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;
	sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
	sConfig.IC1Prescaler = TIM_ICPSC_DIV1;
	sConfig.IC1Filter = 0;
	sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;
	sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
	sConfig.IC2Prescaler = TIM_ICPSC_DIV1;
	sConfig.IC2Filter = 0;
	if (HAL_TIM_Encoder_Init(&htim3, &sConfig) != HAL_OK) {
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig)
			!= HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN TIM3_Init 2 */

	/* USER CODE END TIM3_Init 2 */

}

/**
 * @brief TIM4 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM4_Init(void) {

	/* USER CODE BEGIN TIM4_Init 0 */

	/* USER CODE END TIM4_Init 0 */

	TIM_Encoder_InitTypeDef sConfig = { 0 };
	TIM_MasterConfigTypeDef sMasterConfig = { 0 };

	/* USER CODE BEGIN TIM4_Init 1 */

	/* USER CODE END TIM4_Init 1 */
	htim4.Instance = TIM4;
	htim4.Init.Prescaler = 0;
	htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim4.Init.Period = 65535;
	htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	sConfig.EncoderMode = TIM_ENCODERMODE_TI12;
	sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;
	sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
	sConfig.IC1Prescaler = TIM_ICPSC_DIV1;
	sConfig.IC1Filter = 0;
	sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;
	sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
	sConfig.IC2Prescaler = TIM_ICPSC_DIV1;
	sConfig.IC2Filter = 0;
	if (HAL_TIM_Encoder_Init(&htim4, &sConfig) != HAL_OK) {
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig)
			!= HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN TIM4_Init 2 */

	/* USER CODE END TIM4_Init 2 */

}

/**
 * @brief TIM5 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM5_Init(void) {

	/* USER CODE BEGIN TIM5_Init 0 */

	/* USER CODE END TIM5_Init 0 */

	TIM_ClockConfigTypeDef sClockSourceConfig = { 0 };
	TIM_MasterConfigTypeDef sMasterConfig = { 0 };

	/* USER CODE BEGIN TIM5_Init 1 */

	/* USER CODE END TIM5_Init 1 */
	htim5.Instance = TIM5;
	htim5.Init.Prescaler = 169;
	htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim5.Init.Period = 999;
	htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim5.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim5) != HAL_OK) {
		Error_Handler();
	}
	sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
	if (HAL_TIM_ConfigClockSource(&htim5, &sClockSourceConfig) != HAL_OK) {
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig)
			!= HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN TIM5_Init 2 */

	/* USER CODE END TIM5_Init 2 */

}

/**
 * @brief TIM8 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM8_Init(void) {

	/* USER CODE BEGIN TIM8_Init 0 */

	/* USER CODE END TIM8_Init 0 */

	TIM_ClockConfigTypeDef sClockSourceConfig = { 0 };
	TIM_MasterConfigTypeDef sMasterConfig = { 0 };
	TIM_OC_InitTypeDef sConfigOC = { 0 };
	TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = { 0 };

	/* USER CODE BEGIN TIM8_Init 1 */

	/* USER CODE END TIM8_Init 1 */
	htim8.Instance = TIM8;
	htim8.Init.Prescaler = 169;
	htim8.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim8.Init.Period = 19999;
	htim8.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim8.Init.RepetitionCounter = 0;
	htim8.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim8) != HAL_OK) {
		Error_Handler();
	}
	sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
	if (HAL_TIM_ConfigClockSource(&htim8, &sClockSourceConfig) != HAL_OK) {
		Error_Handler();
	}
	if (HAL_TIM_PWM_Init(&htim8) != HAL_OK) {
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim8, &sMasterConfig)
			!= HAL_OK) {
		Error_Handler();
	}
	sConfigOC.OCMode = TIM_OCMODE_PWM1;
	sConfigOC.Pulse = 0;
	sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
	sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
	sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
	sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
	sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
	if (HAL_TIM_PWM_ConfigChannel(&htim8, &sConfigOC, TIM_CHANNEL_1)
			!= HAL_OK) {
		Error_Handler();
	}
	sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
	sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
	sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
	sBreakDeadTimeConfig.DeadTime = 0;
	sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
	sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
	sBreakDeadTimeConfig.BreakFilter = 0;
	sBreakDeadTimeConfig.BreakAFMode = TIM_BREAK_AFMODE_INPUT;
	sBreakDeadTimeConfig.Break2State = TIM_BREAK2_DISABLE;
	sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
	sBreakDeadTimeConfig.Break2Filter = 0;
	sBreakDeadTimeConfig.Break2AFMode = TIM_BREAK_AFMODE_INPUT;
	sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
	if (HAL_TIMEx_ConfigBreakDeadTime(&htim8, &sBreakDeadTimeConfig)
			!= HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN TIM8_Init 2 */

	/* USER CODE END TIM8_Init 2 */
	HAL_TIM_MspPostInit(&htim8);

}

/**
 * @brief TIM16 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM16_Init(void) {

	/* USER CODE BEGIN TIM16_Init 0 */

	/* USER CODE END TIM16_Init 0 */

	/* USER CODE BEGIN TIM16_Init 1 */

	/* USER CODE END TIM16_Init 1 */
	htim16.Instance = TIM16;
	htim16.Init.Prescaler = 169;
	htim16.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim16.Init.Period = 1145;
	htim16.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim16.Init.RepetitionCounter = 0;
	htim16.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim16) != HAL_OK) {
		Error_Handler();
	}
	if (HAL_TIM_OnePulse_Init(&htim16, TIM_OPMODE_SINGLE) != HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN TIM16_Init 2 */

	/* USER CODE END TIM16_Init 2 */

}

/**
 * @brief USART2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_USART2_UART_Init(void) {

	/* USER CODE BEGIN USART2_Init 0 */

	/* USER CODE END USART2_Init 0 */

	/* USER CODE BEGIN USART2_Init 1 */

	/* USER CODE END USART2_Init 1 */
	huart2.Instance = USART2;
	huart2.Init.BaudRate = 115200;
	huart2.Init.WordLength = UART_WORDLENGTH_9B;
	huart2.Init.StopBits = UART_STOPBITS_1;
	huart2.Init.Parity = UART_PARITY_EVEN;
	huart2.Init.Mode = UART_MODE_TX_RX;
	huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
	huart2.Init.OverSampling = UART_OVERSAMPLING_16;
	huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
	huart2.Init.ClockPrescaler = UART_PRESCALER_DIV1;
	huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
	if (HAL_UART_Init(&huart2) != HAL_OK) {
		Error_Handler();
	}
	if (HAL_UARTEx_SetTxFifoThreshold(&huart2, UART_TXFIFO_THRESHOLD_1_8)
			!= HAL_OK) {
		Error_Handler();
	}
	if (HAL_UARTEx_SetRxFifoThreshold(&huart2, UART_RXFIFO_THRESHOLD_1_8)
			!= HAL_OK) {
		Error_Handler();
	}
	if (HAL_UARTEx_DisableFifoMode(&huart2) != HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN USART2_Init 2 */

	/* USER CODE END USART2_Init 2 */

}

/**
 * Enable DMA controller clock
 */
static void MX_DMA_Init(void) {

	/* DMA controller clock enable */
	__HAL_RCC_DMAMUX1_CLK_ENABLE();
	__HAL_RCC_DMA1_CLK_ENABLE();

	/* DMA interrupt init */
	/* DMA1_Channel1_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
	/* DMA1_Channel2_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel2_IRQn);
	/* DMA1_Channel3_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel3_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel3_IRQn);
	/* DMA1_Channel4_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel4_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel4_IRQn);

}

/**
 * @brief GPIO Initialization Function
 * @param None
 * @retval None
 */
static void MX_GPIO_Init(void) {
	GPIO_InitTypeDef GPIO_InitStruct = { 0 };
	/* USER CODE BEGIN MX_GPIO_Init_1 */

	/* USER CODE END MX_GPIO_Init_1 */

	/* GPIO Ports Clock Enable */
	__HAL_RCC_GPIOC_CLK_ENABLE();
	__HAL_RCC_GPIOF_CLK_ENABLE();
	__HAL_RCC_GPIOA_CLK_ENABLE();
	__HAL_RCC_GPIOB_CLK_ENABLE();

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_6 | GPIO_PIN_7 | GPIO_PIN_10,
			GPIO_PIN_RESET);

	/*Configure GPIO pin : PC13 */
	GPIO_InitStruct.Pin = GPIO_PIN_13;
	GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

	/*Configure GPIO pins : PC3 PC9 */
	GPIO_InitStruct.Pin = GPIO_PIN_3 | GPIO_PIN_9;
	GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

	/*Configure GPIO pins : RUN_Joy_Pin Save_Joy_Pin */
	GPIO_InitStruct.Pin = RUN_Joy_Pin | Save_Joy_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_PULLUP;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

	/*Configure GPIO pin : PA4 */
	GPIO_InitStruct.Pin = GPIO_PIN_4;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

	/*Configure GPIO pin : LD2_Pin */
	GPIO_InitStruct.Pin = LD2_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);

	/*Configure GPIO pins : PB11 PB12 */
	GPIO_InitStruct.Pin = GPIO_PIN_11 | GPIO_PIN_12;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

	/*Configure GPIO pins : PB13 PB14 */
	GPIO_InitStruct.Pin = GPIO_PIN_13 | GPIO_PIN_14;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

	/*Configure GPIO pins : PC6 PC7 PC10 */
	GPIO_InitStruct.Pin = GPIO_PIN_6 | GPIO_PIN_7 | GPIO_PIN_10;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

	/*Configure GPIO pin : PC12 */
	GPIO_InitStruct.Pin = GPIO_PIN_12;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

	/* EXTI interrupt init*/
	HAL_NVIC_SetPriority(EXTI3_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(EXTI3_IRQn);

	HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);

	/* USER CODE BEGIN MX_GPIO_Init_2 */

	/* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */
void Prismatic_CasCadeControl() {
	float setpoint_pris_abs = Trapezoidal_GetCurrentAbsolute(&prisProfile);

	error_pos_pris = setpoint_pris_abs - (float) ball_screw_pos;
	output_pos_pris = arm_pid_f32(&PID_POS_pris, error_pos_pris);

	if (output_pos_pris > 550) {
		output_pos_pris = 550;
	} else if (output_pos_pris < -550) {
		output_pos_pris = -550;
	}

	error_velo_pris = output_pos_pris - ball_screw_vel;
	output_velo_pris = PIDCompute(&prismatic_vel_control, Kp_velo_pris,
			Ki_velo_pris, Kd_velo_pris, error_velo_pris);

	if (limit_r == 1 && output_prismatic < 0) {
		output_prismatic = 0;
	} else if (limit_l == 1 && output_prismatic > 0) {
		output_prismatic = 0;
	}

	// Motor control}
	if (error_pos_pris <= 0.1 && error_pos_pris >= -0.1) {
		output_prismatic = 0;
	} else {
		output_prismatic = output_velo_pris;
	}
}

void Revolute_CasCadeControl() {
	float setpoint_rev_abs = Trapezoidal_GetCurrentAbsolute(&revProfile);
	error_pos_re = setpoint_rev_abs - revolute_encoder.rads;
	output_pos_re = arm_pid_f32(&PID_POS_re, error_pos_re);

	if (output_pos_re > 300) {
		output_pos_re = 300;
	} else if (output_pos_re < -300) {
		output_pos_re = -300;
	}

	error_velo_re = output_pos_re - (revolute_encoder.radps / 2);

	output_velo_re = PIDCompute(&revolute_vel_control, Kp_velo_re, Ki_velo_re,
			Kd_velo_re, error_velo_re);

	if (revolute_flag == 1 && output_revolute > 0) {
		output_revolute = 0;
	} else if (revolute_encoder.rads >= (2 * M_PI) && output_revolute < 0) {
		output_revolute = 0;
	}
	// Motor control
	if (error_pos_re <= 0.0035 && error_pos_re >= -0.0035) {
		output_revolute = 0;
	} else {
		output_revolute = output_velo_re;
	}
}

void ball_screw_converter() {
	ball_screw_pos = (prismatic_encoder.rads * (16.00f / (2.0f * M_PI)));
	ball_screw_vel = prismatic_radps_lowpass * (16.0f / (2.0f * M_PI));
}

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
	if (GPIO_Pin == GPIO_PIN_13) {
		current_state = STATE_ERROR;
		registerFrame[1].U16 = STATUS_IDLE;
	}
}

long map(long x, long in_min, long in_max, long out_min, long out_max) {
	return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

float mapf(float x, float in_min, float in_max, float out_min, float out_max) {
	return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {

	// sensor timer 1000 hz
	if (htim == &htim2) {
		HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);
//		MotorSet(&revolute_motor, 1000, 65535);
		QEIPosVelUpdate(&prismatic_encoder);
		QEIPosVelUpdate(&revolute_encoder);
		//Limit Switch check
		limit_l = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_11);
		limit_r = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_12);
		limit_plot = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_13);
		//Joy Calculate

		// filter
		int32_t sum_x = 0, sum_y = 0;
		for (int i = 0; i < 20; i++) {
			if ((i & 1) == 0)
				sum_y += JOY_RawRead[i];
			else
				sum_x += JOY_RawRead[i];
		}

		int32_t raw_x = sum_x / 10;
		int32_t raw_y = sum_y / 10;

		if (raw_x < 1700 && raw_x > 1500) {
			raw_x = 3400 / 2;
		}
		if (raw_y < 1700 && raw_y > 1500) {
			raw_y = 3400 / 2;
		}

		Joy_x = map(raw_x, RAW_MIN, RAW_MAX, OUT_MIN, OUT_MAX);
		Joy_y = map(raw_y, RAW_MIN, RAW_MAX, OUT_MIN, OUT_MAX);

		// Joy button
//		Joy_run = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0);
//		Joy_save = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_1);

		//Prismatic Low pass filter
		prismatic_radps_lowpass = prismatic_radps_lowpass_prev
				+ alpha
						* (prismatic_encoder.radps
								- prismatic_radps_lowpass_prev);

		prismatic_acceleration = ((prismatic_radps_lowpass
				- prismatic_radps_lowpass_prev) / dt);
		prismatic_radps_lowpass_prev = prismatic_radps_lowpass;
		prismatic_acceleration_lowpass = prismatic_acceleration_lowpass_prev
				+ alpha
						* (prismatic_acceleration
								- prismatic_acceleration_lowpass_prev);
		ball_screw_converter();

		// ==== Revolute Low‐Pass Filter ====
		// 1) กรองความเร็ว (rad/s) ของแกน Revolute
		revolute_radps_lowpass =
				revolute_radps_lowpass_prev
						+ alpha
								* (revolute_encoder.radps
										- revolute_radps_lowpass_prev);
		// 2) คำนวณอัตราเร่งดิบ (rad/s^2) จากความเปลี่ยนแปลงของค่าที่กรองแล้ว
		revolute_acceleration = (revolute_radps_lowpass
				- revolute_radps_lowpass_prev) / dt;
		// 3) กรองอัตราเร่งให้ลื่น (หากต้องการใช้ค่าเร่งหลังกรอง)
		revolute_acceleration_lowpass = revolute_acceleration_lowpass_prev
				+ alpha
						* (revolute_acceleration
								- revolute_acceleration_lowpass_prev);
		// 4) เก็บสถานะย้อนกลับไว้ใช้รอบถัดไป
		revolute_radps_lowpass_prev = revolute_radps_lowpass;
		revolute_acceleration_lowpass_prev = revolute_acceleration_lowpass;

		// Prox shimttrigger
//		revolute_flag = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4);
		if (Prox_RawRead[0] > 3000) {
			revolute_flag = 0;
		} else if (Prox_RawRead[0] < 1500) {
			revolute_flag = 1;
		}

		//Servo
		if (registerFrame[4].U16 == 1) {
			__HAL_TIM_SET_COMPARE(&htim8, TIM_CHANNEL_1, 1600);
		} else if (registerFrame[5].U16 == 1) {
			__HAL_TIM_SET_COMPARE(&htim8, TIM_CHANNEL_1, 2200);
		}
//		__HAL_TIM_SET_COMPARE(&htim8, TIM_CHANNEL_1, motor_voltage);
		//button
		Joy_save = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_13);
		Joy_run = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_14);
		button_emer =
				(HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13) == GPIO_PIN_SET) ? 1 : 0;

		button_reset =
				(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_13) == GPIO_PIN_SET
						&& button_emer == 1) ? 1 : 0;

		button_run =
				(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_14) == GPIO_PIN_SET
						&& button_emer) ? 1 : 0;

		MotorSet(&prismatic_motor, 1000, output_prismatic);
		MotorSet(&revolute_motor, 1000, output_revolute);

		// Protocal
		// Heart beat protocal 0.5 sec
		if (heartbeat_counter > 500) {
			heartbeat_counter = 0;
			registerFrame[0x00].U16 =
					(registerFrame[0X00].U16 == 0) ? 22881 : 0;
		}
		heartbeat_counter++;
	}

	// state timer 1000 hz
	if (htim == &htim5) {

		registerFrame[11].U16 = (int) (300.0 - (ball_screw_pos * 10));
		registerFrame[12].U16 = (int) (revolute_encoder.rads * (18 / 2 * M_PI)
				* 10);
		registerFrame[13].U16 = (int) (ball_screw_vel * 10);
		registerFrame[14].U16 = (int) (revProfile.current_velocity
				* (180 / 2 * M_PI) * 10);
		registerFrame[15].U16 = (int) (prismatic_acceleration_lowpass * 10);
		registerFrame[16].U16 = (int) (revolute_acceleration_lowpass * 10);

		// ตรวจสอบคำสั่งหยุดฉุกเฉิน (มีความสำคัญสูงสุด)
		if (registerFrame[1].U16 & STATUS_STOP) {
			current_state = STATE_STOPPING;
		}
		if ((registerFrame[1].U16 & STATUS_HOME) && pain_flang == 0) {
			current_state = STATE_HOMING;
		} else if ((registerFrame[1].U16 & STATUS_JOG) && running_flang == 0) {
			current_state = STATE_JOGGING;
			registerFrame[10].U16 = STATUS_JOG;
		} else if (registerFrame[1].U16 & STATUS_POINT) {
			current_state = STATE_POINT_MOVING;
			pointMoveNeedsInit = 1;
			registerFrame[10].U16 = STATUS_POINT;
		} else if (registerFrame[1].U16 & STATUS_GO_TO_TARGET) {
			current_state = STATE_GO_TO_TARGET;
			registerFrame[10].U16 = STATUS_GO_TO_TARGET;
		} else if (registerFrame[1].U16 & STATUS_IDLE) {
			current_state = STATE_IDLE;
		} else if (registerFrame[1].U16 & STATUS_TEST) {
			current_state = STATE_TEST;
		}

		if (registerFrame[4].U16 == 1 && registerFrame[5].U16 == 0) {
			//Pen Up Servo On
			registerFrame[3].U16 = 1 << 0;
		} else {
			//Pen Doen Servo Off
			registerFrame[3].U16 = 1 << 1;
		}

		if (button_reset == 1
				&& (current_state == STATE_ERROR || current_state == STATE_IDLE)
				&& button_emer == 1) {
			registerFrame[1].U16 = STATUS_HOME;
		}

		switch (current_state) {
		case STATE_HOMING:

			if (pen_flag == 0) {
				pen_flag = 1;
				count_time = 0;
			}

			if (count_time <= 1500) {
				output_prismatic = 0;
				output_revolute = 0;
				registerFrame[4].U16 = 1;
				registerFrame[5].U16 = 0;
				count_time++;
			} else {
				if (limit_r != 1) {
					output_prismatic = -(65535 / 2.0);
				} else if (limit_r == 1) {
					limit_l_prev = 1;
					output_prismatic = 0;
					QEI_Reset(&prismatic_encoder);
					QEIInit(&prismatic_encoder, &htim4, 8192, 1000, 65536);
				}
				if (revolute_flag != 1) {
					output_revolute = -60000;
				} else if (revolute_flag == 1) {
					revolute_homed = 1; // Check Proximity trick
					output_revolute = 0;
					QEI_Reset(&revolute_encoder);
					QEIInit(&revolute_encoder, &htim3, 8192, 1000, 65536);
				}

				registerFrame[11].U16 = 0;
				registerFrame[12].U16 = 0;
				registerFrame[13].U16 = 0;
				registerFrame[14].U16 = 0;
				registerFrame[15].U16 = 0;
				registerFrame[16].U16 = 0;

				target_position_prismatic = 0;
				target_position_revolute = 0;
				error_pos_re = 0;
				error_pos_pris = 0;
				registerFrame[10].U16 = STATUS_HOME;
				if (button_run == 1) {
					current_state = STATE_PAIN;
					pain_flang = 1;
				}
			}
			break;
		case STATE_PAIN:
			// ถ้าวิ่งจนครบทุกจุด ให้ข้ามไปโฮมมิ่ง
			if (path_idx >= PATH_POINTS) {
				registerFrame[4].U16 = 1;
				registerFrame[5].U16 = 0;
				pain_flang = 0;
				current_state = STATE_HOMING;
				break;
			}

			if (painInit) {
				float x_mm = path[path_idx][0];
				float y_mm = path[path_idx][1];

//				path_idx_prev = path_idx;
//				if (x_mm == -1 && y_mm == -1 && path_idx >= path_idx_prev + 1) {
//					registerFrame[4].U16 = 1;
//					registerFrame[5].U16 = 0;
////					path_idx++;
//				} else {
//					registerFrame[4].U16 = 0;
//					registerFrame[5].U16 = 1;
//				}

				if (x_mm == -1 && y_mm == -1) {
					path_idx++;
					x_mm = path[path_idx][0];
					y_mm = path[path_idx][1];

					path_idx_prev = 1;
				}

				if (path_idx_prev > 0) {
					registerFrame[4].U16 = 1;
					registerFrame[5].U16 = 0;
					path_idx_prev--;
				} else {
					registerFrame[4].U16 = 0;
					registerFrame[5].U16 = 1;
				}

				theta = atan2(y_mm, x_mm);
				if (theta < 0.0f)
					theta += 2.0f * M_PI;

				theta *= 2.0;

				if (theta <= 2.0 * M_PI) {
					target_position_revolute = theta;
					target_position_prismatic = 300
							+ (sqrt((x_mm * x_mm) + (y_mm * y_mm)));
				} else if (theta > 2.0 * M_PI) {
					target_position_revolute = (float) (fabs(M_PI - theta));
					target_position_prismatic = mapf(
							sqrt((x_mm * x_mm) + (y_mm * y_mm)), -300, 0, 300,
							600);
				}

				Trapezoidal_Init(&prisProfile, (float) ball_screw_pos,
						target_position_prismatic, 550.0f, 250.0f);
				Trapezoidal_Init(&revProfile, revolute_encoder.rads,
						target_position_revolute, 2.0f, 0.4f);

				painInit = 0;
			}

			if (!prisProfile.finished)
				Trapezoidal_Update(&prisProfile, dt);
			if (!revProfile.finished)
				Trapezoidal_Update(&revProfile, dt);
			Prismatic_CasCadeControl();

			Kp_pos_re = 3.0;
			Ki_pos_re = 0.0005;
			Kd_pos_re = 0.0;

			Kp_velo_re = 5000.0;
			Ki_velo_re = 0.5;
			Kd_velo_re = 0.0;

			PID_POS_re.Kp = Kp_pos_re;
			PID_POS_re.Ki = Ki_pos_re;
			PID_POS_re.Kd = Kd_pos_re;
			arm_pid_init_f32(&PID_POS_re, 0);
			Revolute_CasCadeControl();

			if ((limit_r && output_prismatic < 0)
					|| (limit_l && output_prismatic > 0))
				output_prismatic = 0;
			if ((revolute_flag && output_revolute < 0)
					|| (revolute_encoder.rads >= 2.0f * M_PI
							&& output_revolute > 0))
				output_revolute = 0;

//			if (prisProfile.finished && revProfile.finished) {
			if (prisProfile.finished && revProfile.finished
					&& output_prismatic == 0 && output_revolute == 0) {
//				registerFrame[4].U16 = 0;
//				registerFrame[5].U16 = 1;
				path_idx++;
				painInit = 1;
			}
			break;
		case STATE_JOGGING:
			//Call joystick mode
//			registerFrame[4].U16 = 1;
//			registerFrame[5].U16 = 0;
//			joy_flag = 1;

			if (limit_r == 1) {
				output_prismatic = 0;
//				QEI_Reset(&prismatic_encoder);
//				QEIInit(&prismatic_encoder, &htim4, 8192, 1000, 65536);
			}

			if (revolute_flag == 1) {
				output_revolute = 0;
//				QEI_Reset(&revolute_encoder);
//				QEIInit(&revolute_encoder, &htim3, 8192, 1000, 65536);
			}

			output_prismatic = (Joy_x / 100.0) * 20000;

			if (limit_r == 1 && output_prismatic < 0) {
				output_prismatic = 0;
			} else if (limit_l == 1 && output_prismatic > 0) {
				output_prismatic = 0;
			}

			output_revolute = (Joy_y / 100.0) * 30000.0;

			if (revolute_flag == 1 && output_revolute < 0) {
				output_revolute = 0;
			} else if (revolute_encoder.rads >= (2 * M_PI)
					&& output_revolute > 0) {
				output_revolute = 0;
			}

			if (button_reset == 1) {
				count_run = 0;
				current_state = STATE_RUNING;
				pointRunNeedsInit = 1;
				running_flang = 1;
//				registerFrame[4].U16 = 1;
//				registerFrame[5].U16 = 0;
			}

			if (button_run == 1 && button_run_prev == 0) {
				if (count >= 0 && count < 10) {
					registerFrame[20 + count * 2].U16 = ball_screw_pos * 10;
					registerFrame[21 + count * 2].U16 = (revolute_encoder.rads
							/ (2 * M_PI)) * 1800.0;

					ten_point[count][0] = (float) ball_screw_pos;
					ten_point[count][1] = (float) revolute_encoder.rads;

//					registerFrame[18 + count * 2].U16 = (float) ball_screw_pos;
//					registerFrame[19 + count * 2].U16 =
//							(float) revolute_encoder.rads;
				} else {
					count = 0;
				}
				count++;
			}

			pen_flag = 0;
			break;
		case STATE_RUNING:

			if (pointRunNeedsInit == 1) {
				registerFrame[4].U16 = 1;
				registerFrame[5].U16 = 0;

				target_position_prismatic = (float) (ten_point[count_run][0]);
				target_position_revolute = (float) (ten_point[count_run][1]);

				count_run++;

				float abs_start_pris = (float) ball_screw_pos;
				float abs_goal_pris = target_position_prismatic;  // (mm)

				Trapezoidal_Init(&prisProfile, abs_start_pris, abs_goal_pris,
						550.0f, // v_max (mm/s)
						250.0f); // a_max (mm/s²)

				float abs_start_rev = (float) revolute_encoder.rads;
				float abs_goal_rev = target_position_revolute/* from registerFrame[65], converted to radians */;

				Trapezoidal_Init(&revProfile, abs_start_rev, abs_goal_rev, 2.0f, // v_max (rad/s)
						0.4f); // a_max (rad/s²)
				pointRunNeedsInit = 0;
			}

			if (!prisProfile.finished) {
				Trapezoidal_Update(&prisProfile, 0.001f);
			}
			if (!revProfile.finished) {
				Trapezoidal_Update(&revProfile, 0.001f);
			}

			if (output_prismatic == 0 && output_revolute == 0
					&& prisProfile.finished && revProfile.finished) {

				if (ten_flag == 0) {
					ten_flag = 1;
					ten_count = 0;

				} else {
					if (ten_count <= 1500) {
						registerFrame[4].U16 = 0;
						registerFrame[5].U16 = 1;
						output_prismatic = 0;
						output_revolute = 0;
						ten_count++;
					} else if (ten_count <= 3000) {
						registerFrame[4].U16 = 1;
						registerFrame[5].U16 = 0;
						ten_count++;
					} else {
						pointRunNeedsInit = 1;
						ten_flag = 0;
					}
				}

			} else {

				Revolute_CasCadeControl();
				Prismatic_CasCadeControl();

				if (limit_r == 1 && limit_l_prev == 0) {
					output_prismatic = 0;
				}

				if (revolute_flag == 1 && revolute_homed == 0) {
					output_revolute = 0;
				}

			}

//			if (button_reset && !button_reset_prev) {
////				count_run++;
//				pointRunNeedsInit = 1;
//			}
//
			if (button_run == 1 || count_run > count) {
				running_flang = 0;
				current_state = STATE_JOGGING;
				count_run = 0;
			}
			pen_flag = 0;
			break;
		case STATE_POINT_MOVING:
//			registerFrame[4].U16 = 1;
//			registerFrame[5].U16 = 0;
			theta = (float) (registerFrame[65].U16);
			if (theta <= 1800) {
				target_position_revolute = (float) (registerFrame[65].U16
						/ 1800.0) * (2.0 * M_PI);
				target_position_prismatic = 300 - (registerFrame[64].U16 / 10);
			} else if (theta >= 1800) {
				target_position_revolute = (float) (fabs(
						180 - registerFrame[65].U16 / 10.0));
				target_position_revolute = (float) (target_position_revolute
						/ 180.0) * (2.0 * M_PI);
				target_position_prismatic = mapf((registerFrame[64].U16 / 10),
						0, 300, 300, 600);
			}
			if (pointMoveNeedsInit) {
				float abs_start_pris = (float) ball_screw_pos;
				float abs_goal_pris = target_position_prismatic;

				Trapezoidal_Init(&prisProfile, abs_start_pris, abs_goal_pris,
						550.0f, 250.0f);

				float abs_start_rev = (float) revolute_encoder.rads;
				float abs_goal_rev = target_position_revolute;

				Trapezoidal_Init(&revProfile, abs_start_rev, abs_goal_rev, 2.0f, // v_max (rad/s)
						0.4f); // a_max (rad/s²)

				pointMoveNeedsInit = 0;
			}
			pen_flag = 0;
			break;
		case STATE_GO_TO_TARGET:

			if (!prisProfile.finished) {
				Trapezoidal_Update(&prisProfile, 0.001f);
			}
			if (!revProfile.finished) {
				Trapezoidal_Update(&revProfile, 0.001f);
			}

			Revolute_CasCadeControl();
			Prismatic_CasCadeControl();

			if (limit_r == 1 && limit_l_prev == 0) {
				output_prismatic = 0;
				QEI_Reset(&prismatic_encoder);
				QEIInit(&prismatic_encoder, &htim4, 8192, 1000, 65536);
			}

			if (revolute_flag == 1 && revolute_homed == 0) {
				output_revolute = 0;
				QEI_Reset(&revolute_encoder);
				QEIInit(&revolute_encoder, &htim3, 8192, 1000, 65536);
			}
//			registerFrame[11].U16 = (int) (ball_screw_pos * 10);
//			registerFrame[12].U16 = (int) (revolute_encoder.rads * (180 / 2 * M_PI)
//					* 10);
//			registerFrame[13].U16 = (int) (ball_screw_vel * 10);
//			registerFrame[14].U16 = (int) (revProfile.current_velocity * (180 / 2 * M_PI)
//					* 10);
//			registerFrame[15].U16 = (int) (prismatic_acceleration_lowpass * 10);
//			registerFrame[16].U16 = (int) (revolute_acceleration_lowpass * 10);

			if (output_prismatic == 0 && output_revolute == 0
					&& prisProfile.finished && revProfile.finished) {
				registerFrame[1].U16 = STATUS_STOP;
			}
//			if (prisProfile.finished && revProfile.finished && output_prismatic == 0 ) {
//				registerFrame[1].U16 = STATUS_STOP;
//			}
			pen_flag = 0;
			break;

		case STATE_STOPPING:
			registerFrame[10].U16 = STATUS_STOP;
			revolute_homed = 0;
			limit_l_prev = 0;
			output_revolute = 0;
			output_prismatic = 0;
//			registerFrame[4].U16 = 0;
//			registerFrame[5].U16 = 1;
			pen_flag = 0;
			break;

		case STATE_ERROR:
			//when emergency trick
			output_revolute = 0;
			output_prismatic = 0;
//			registerFrame[4].U16 = 0;
//			registerFrame[5].U16 = 1;
			pen_flag = 0;
			pain_flang = 0;
			break;
		case STATE_TEST:
			if (limit_r == 1) {
				output_prismatic = 0;
				QEI_Reset(&prismatic_encoder);
				QEIInit(&prismatic_encoder, &htim4, 8192, 1000, 65536);
			}

			if (revolute_flag == 1) {
				output_revolute = 0;
				QEI_Reset(&revolute_encoder);
				QEIInit(&revolute_encoder, &htim3, 8192, 1000, 65536);
			}

			output_prismatic = (Joy_x / 100.0) * 65535.0;

			if (limit_r == 1 && output_prismatic < 0) {
				output_prismatic = 0;
			} else if (limit_l == 1 && output_prismatic > 0) {
				output_prismatic = 0;
			}

			output_revolute = (Joy_y / 100.0) * 65535.0;

			if (revolute_flag == 1 && output_revolute < 0) {
				output_revolute = 0;
			} else if (revolute_encoder.rads >= (2 * M_PI)
					&& output_revolute > 0) {
				output_revolute = 0;
			}

			pen_flag = 0;
			break;
		}
		button_reset_prev = button_reset;
		button_run_prev = button_run;
	}
}
/* USER CODE END 4 */

/**
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void Error_Handler(void) {
	/* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */
	__disable_irq();
	while (1) {
	}
	/* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
