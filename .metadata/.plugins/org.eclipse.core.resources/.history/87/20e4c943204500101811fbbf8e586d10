/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file           : main.c
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "motor.h"
#include "arm_math.h"
#include "QEI.h"
#include "PID.h"
#include "Kalman.h"
#include "ModBusRTU.h"
#include "math.h"
#include "Trapezoidal.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
#define PRISM_UPDATE_THRESH 40.0f
// LOW PASS cutoff frequency
#define FC   5.0f
#define VELOCITY_DEADZONE   0.01f   // ปรับตามหน่วย rads/s หรือ mm/s ที่เหมาะสม
//Joy set origin
#define RAW_MIN    0    // e.g. you saw ~20 at one end
#define RAW_CENTER 1750  // you measured ~1700–1800 at rest
#define RAW_MAX   3400   // you saw ~4080 at the other end
#define OUT_MIN  -100
#define OUT_MAX  +100
#define PATH_POINTS  (sizeof(path)/sizeof(path[0]))
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;
ADC_HandleTypeDef hadc2;
DMA_HandleTypeDef hdma_adc1;
DMA_HandleTypeDef hdma_adc2;

TIM_HandleTypeDef htim1;
TIM_HandleTypeDef htim2;
TIM_HandleTypeDef htim3;
TIM_HandleTypeDef htim4;
TIM_HandleTypeDef htim5;
TIM_HandleTypeDef htim8;
TIM_HandleTypeDef htim16;

UART_HandleTypeDef huart2;
DMA_HandleTypeDef hdma_usart2_rx;
DMA_HandleTypeDef hdma_usart2_tx;

/* USER CODE BEGIN PV */
// Velo profile
VELO_PROFILE prisProfile;
VELO_PROFILE revProfile;

ModbusHandleTypedef hmodbus;
volatile u16u8_t registerFrame[70];
//state machine
typedef enum {
	STATUS_IDLE = 0, STATUS_HOME = 1 << 0,        // 00001 = 1 - สถานะโฮมมิ่ง
	STATUS_JOG = 1 << 1,         // 00010 = 2 - สถานะจ็อกกิ้ง
	STATUS_POINT = 1 << 2,       // 00100 = 4 - สถานะเคลื่อนที่แบบจุดต่อจุด
	STATUS_GO_TO_TARGET = 1 << 3,       // 01000 = 8 - สถานะไปยังตำแหน่งเป้าหมาย
	STATUS_STOP = 1 << 4,         // 10000 = 16 - สถานะหยุดฉุกเฉิน
	STATUS_TEST = 1 << 5
} MovingStatusFlags;

typedef enum {
	STATE_IDLE,
	STATE_HOMING,
	STATE_JOGGING,
	STATE_POINT_MOVING,
	STATE_GO_TO_TARGET,
	STATE_STOPPING,
	STATE_ERROR,
	STATE_RUNING,
	STATE_PAIN,
	STATE_TEST
} RobotState;

typedef enum {
	SERVO_STATE,
} Servo_state;

RobotState current_state = STATE_IDLE;
int joy_flag = 0;
int point_flag = 0;
float joy_save[10];

MOTOR prismatic_motor;
MOTOR revolute_motor;
MOTOR servo_motor;

float target_position_prismatic = 0.0;

// PID_Velocity gain
float Kp_velo_pris = 100.0;
float Ki_velo_pris = 2.0;      //8.5;
float Kd_velo_pris = 0.0;
float output_velo_pris = 0.00;
float error_velo_pris = 0.00;

// PID_Position gain
//float Kp_pos = 4.5; encoder
float Kp_pos_pris = 6.0;
float Ki_pos_pris = 0.0;
float Kd_pos_pris = 0.0;
float output_pos_pris = 0.00;
float error_pos_pris = 0.00;

//PID_Position CMSIS
arm_pid_instance_f32 PID_POS_pris = { 0 };
arm_pid_instance_f32 PID_POS_re = { 0 };

int32_t setpoint = 0;
float output_prismatic = 0;
float output_revolute = 0;

QEI prismatic_encoder;
CONTROLLER prismatic_pos_control;
CONTROLLER prismatic_vel_control;

// Prismatic low-pass
// LOW Pass filter
const float dt = 0.001f;
const float RC = 1.0f / (2.0f * 3.1415926f * FC);
const float alpha = dt / (RC + dt);
float prismatic_radps_lowpass_prev = 0.0f;  // filter state
float prismatic_radps_lowpass = 0.0f;

// Acceleration
float prismatic_acceleration = 0.0f;
float prismatic_acceleration_lowpass = 0.0f;
float prismatic_acceleration_lowpass_prev = 0.0f;

// unit converter
double ball_screw_pos;
double ball_screw_vel;

//REvolute
float target_position_revolute = 0.0;

QEI revolute_encoder;
uint8_t revolute_flag = 0;
CONTROLLER revolute_pos_control;
CONTROLLER revolute_vel_control;

// unit converter
uint8_t limit_r = 0;
uint8_t limit_r_prev = 0;
uint8_t limit_l = 0;
uint8_t limit_l_prev = 0;
uint8_t limit_plot = 0;

float motor_voltage = 0.0;
float error_rads = 0.0;

// PID_Velocity gain
//float Kp_pos_re = 3.0;				//original 5
//float Ki_pos_re = 0.00035;         //8.5;    //8.5;
//float Kd_pos_re = 2.0;
float Kp_pos_re = 3.0;				//original 5
float Ki_pos_re = 0.00035;         //8.5;
float Kd_pos_re = 0.0;
float output_pos_re = 0.00;
float error_pos_re = 0.00;

//Revolute Velo Control
//float Kp_velo_re = 3000.0;
//float Ki_velo_re = 0.2;         //8.5;
//float Kd_velo_re = 0.0;
float Kp_velo_re = 5000.0;			//original 5000
float Ki_velo_re = 0.5;         //8.5;
float Kd_velo_re = 0.0;
float output_velo_re = 0.00;
float error_velo_re = 0.00;

//Revolute Low Pass
float revolute_radps_lowpass_prev = 0.0f;  // สถานะเก่าของความเร็วหลังกรอง
float revolute_radps_lowpass = 0.0f;  // ค่าความเร็วหลังกรองปัจจุบัน
float revolute_acceleration = 0.0f;  // เราจะคำนวณอัตราเร่ง (ดิบ)
float revolute_acceleration_lowpass_prev = 0.0f; // สถานะเก่าของอัตราเร่งหลังกรอง
float revolute_acceleration_lowpass = 0.0f;  // อัตราเร่งหลังกรอง

//Base system
uint64_t heartbeat_counter = 0;
float prev_prismatic_vel = 0.0;
float prev_prismatic_kalman_radps = 0.0;
float prev_revolute_vel = 0.0;

// Validation
uint32_t tim2_counter = 0;
uint8_t burst_mode = 0;
uint8_t flag = 0;

//JOY
uint16_t JOY_RawRead[20];
int16_t Joy_x;
int16_t Joy_y;
uint8_t Joy_run;
uint8_t Joy_save;
int count = 0.0;
int count_run = 0.0;
int count_time = 0.0;

//Proximity
uint16_t Prox_RawRead[10];
uint8_t revolute_homed = 0;

// State
uint8_t state = 0;
uint8_t button_reset = 0;
uint8_t button_reset_prev = 0;
uint8_t button_run = 0;
uint8_t waiting_state = 0;
uint8_t button_emer = 0;

//remap
float remap_pos = 0.0;
float remap_deg = 0.0;
float theta = 0.0;

uint32_t stopCounter = 0;
uint8_t pointMoveNeedsInit = 0;
uint8_t running_flang = 0;
uint8_t pain_flang = 0;
uint8_t pointRunNeedsInit = 0;
uint8_t pen_flag = 0;

static uint16_t path_idx = 0;
static uint8_t painInit = 1;
uint8_t count_pain = 0;
float goal_r_mm = 0.0;
float goal_th_deg = 0.0;

float ten_point[10][2] = { { 0.0, 0.0 }, { 0.0, 0.0 }, { 0.0, 0.0 },
		{ 0.0, 0.0 }, { 0.0, 0.0 }, { 0.0, 0.0 }, { 0.0, 0.0 }, { 0.0, 0.0 }, {
				0.0, 0.0 }, { 0.0, 0.0 } };
uint8_t ten_flag = 0;
uint32_t ten_count = 0;

const float path[][2] = { { 180.35, 11.28 }, { 180.29, 18.96 },
		{ 180.23, 26.65 }, { 180.17, 34.34 }, { 180.11, 42.02 },
		{ 180.05, 49.71 }, { 179.99, 57.39 }, { 179.93, 65.08 },
		{ 179.88, 72.76 }, { 179.82, 80.45 }, { 179.76, 88.14 },
		{ 180.64, 11.57 }, { 177.21, 11.51 }, { 173.77, 11.45 },
		{ 170.34, 11.39 }, { 166.91, 11.34 }, { 163.48, 11.28 },
		{ 160.05, 11.22 }, { 156.61, 11.16 }, { 153.18, 11.10 },
		{ 149.75, 11.04 }, { 146.32, 10.98 }, { 180.35, 33.57 },
		{ 177.59, 33.60 }, { 174.83, 33.63 }, { 172.07, 33.66 },
		{ 169.32, 33.69 }, { 166.56, 33.72 }, { 163.80, 33.75 },
		{ 161.04, 33.78 }, { 158.29, 33.81 }, { 155.53, 33.84 },
		{ 152.77, 33.87 }, { 140.74, 10.40 }, { 138.60, 10.43 },
		{ 136.46, 10.46 }, { 134.32, 10.49 }, { 132.18, 10.51 },
		{ 130.04, 10.54 }, { 127.89, 10.57 }, { 125.75, 10.60 },
		{ 123.61, 10.63 }, { 121.47, 10.66 }, { 119.33, 10.69 },
		{ 131.65, 10.10 }, { 131.59, 17.82 }, { 131.53, 25.53 },
		{ 131.47, 33.25 }, { 131.41, 40.96 }, { 131.36, 48.68 },
		{ 131.30, 56.40 }, { 131.24, 64.11 }, { 131.18, 71.83 },
		{ 131.12, 79.54 }, { 131.06, 87.26 }, { 141.04, 88.43 },
		{ 138.89, 88.34 }, { 136.75, 88.25 }, { 134.61, 88.16 },
		{ 132.47, 88.08 }, { 130.33, 87.99 }, { 128.19, 87.90 },
		{ 126.05, 87.81 }, { 123.90, 87.72 }, { 121.76, 87.64 },
		{ 119.62, 87.55 }, { 101.73, 89.02 }, { 101.73, 81.30 },
		{ 101.73, 73.59 }, { 101.73, 65.87 }, { 101.73, 58.16 },
		{ 101.73, 50.44 }, { 101.73, 42.72 }, { 101.73, 35.01 },
		{ 101.73, 27.29 }, { 101.73, 19.58 }, { 101.73, 11.86 },
		{ 101.73, 11.86 }, { 99.38, 11.86 }, { 97.03, 11.86 }, { 94.69, 11.86 },
		{ 92.34, 11.86 }, { 89.99, 11.86 }, { 87.65, 11.86 }, { 85.30, 11.86 },
		{ 82.95, 11.86 }, { 80.61, 11.86 }, { 78.26, 11.86 }, { 78.26, 11.86 },
		{ 76.73, 13.30 }, { 75.21, 14.74 }, { 73.68, 16.18 }, { 72.16, 17.61 },
		{ 70.63, 19.05 }, { 69.11, 20.49 }, { 67.58, 21.93 }, { 66.06, 23.36 },
		{ 64.53, 24.80 }, { 63.00, 26.24 }, { 63.00, 26.24 }, { 64.33, 27.88 },
		{ 65.65, 29.52 }, { 66.97, 31.17 }, { 68.29, 32.81 }, { 69.61, 34.45 },
		{ 70.93, 36.10 }, { 72.25, 37.74 }, { 73.57, 39.38 }, { 74.89, 41.02 },
		{ 76.21, 42.67 }, { 76.21, 42.67 }, { 78.73, 42.70 }, { 81.25, 42.72 },
		{ 83.77, 42.75 }, { 86.30, 42.78 }, { 88.82, 42.81 }, { 91.34, 42.84 },
		{ 93.87, 42.87 }, { 96.39, 42.90 }, { 98.91, 42.93 }, { 101.43, 42.96 },
		{ 76.21, 42.67 }, { 74.89, 44.13 }, { 73.57, 45.60 }, { 72.25, 47.07 },
		{ 70.93, 48.53 }, { 69.61, 50.00 }, { 68.29, 51.47 }, { 66.97, 52.93 },
		{ 65.65, 54.40 }, { 64.33, 55.87 }, { 63.00, 57.33 }, { 63.00, 57.33 },
		{ 63.03, 59.39 }, { 63.06, 61.44 }, { 63.09, 63.49 }, { 63.12, 65.55 },
		{ 63.15, 67.60 }, { 63.18, 69.65 }, { 63.21, 71.71 }, { 63.24, 73.76 },
		{ 63.27, 75.81 }, { 63.30, 77.87 }, { 63.30, 77.87 }, { 64.47, 79.07 },
		{ 65.65, 80.27 }, { 66.82, 81.48 }, { 67.99, 82.68 }, { 69.17, 83.88 },
		{ 70.34, 85.08 }, { 71.51, 86.29 }, { 72.69, 87.49 }, { 73.86, 88.69 },
		{ 75.03, 89.90 }, { 75.03, 89.90 }, { 77.79, 89.75 }, { 80.55, 89.60 },
		{ 83.30, 89.46 }, { 86.06, 89.31 }, { 88.82, 89.16 }, { 91.58, 89.02 },
		{ 94.33, 88.87 }, { 97.09, 88.72 }, { 99.85, 88.58 }, { 102.61, 88.43 },
		{ -4.17, 84.91 }, { -8.04, 84.85 }, { -11.92, 84.79 },
		{ -15.79, 84.73 }, { -19.66, 84.67 }, { -23.53, 84.62 },
		{ -27.41, 84.56 }, { -31.28, 84.50 }, { -35.15, 84.44 },
		{ -39.02, 84.38 }, { -42.89, 84.32 }, { -75.75, 50.59 },
		{ -79.09, 50.53 }, { -82.44, 50.47 }, { -85.78, 50.41 },
		{ -89.13, 50.35 }, { -92.47, 50.29 }, { -95.82, 50.23 },
		{ -99.16, 50.18 }, { -102.50, 50.12 }, { -105.85, 50.06 }, { -109.19,
				50.00 }, { -109.19, 50.00 }, { -109.16, 52.08 }, { -109.13,
				54.17 }, { -109.10, 56.25 }, { -109.07, 58.33 }, { -109.05,
				60.41 }, { -109.02, 62.50 }, { -108.99, 64.58 }, { -108.96,
				66.66 }, { -108.93, 68.75 }, { -108.90, 70.83 }, { -108.90,
				70.83 }, { -107.75, 72.21 }, { -106.61, 73.59 }, { -105.47,
				74.96 }, { -104.32, 76.34 }, { -103.18, 77.72 }, { -102.03,
				79.10 }, { -100.89, 80.48 }, { -99.75, 81.86 },
		{ -98.60, 83.24 }, { -97.46, 84.62 }, { -97.46, 84.62 },
		{ -94.82, 84.62 }, { -92.18, 84.62 }, { -89.54, 84.62 },
		{ -86.90, 84.62 }, { -84.26, 84.62 }, { -81.62, 84.62 },
		{ -78.98, 84.62 }, { -76.34, 84.62 }, { -73.70, 84.62 },
		{ -71.06, 84.62 }, { -71.06, 84.62 }, { -69.21, 83.12 },
		{ -67.36, 81.62 }, { -65.51, 80.13 }, { -63.66, 78.63 },
		{ -61.82, 77.13 }, { -59.97, 75.64 }, { -58.12, 74.14 },
		{ -56.27, 72.65 }, { -54.42, 71.15 }, { -52.58, 69.65 },
		{ -52.58, 69.65 }, { -52.55, 66.05 }, { -52.52, 62.44 },
		{ -52.49, 58.83 }, { -52.46, 55.22 }, { -52.43, 51.61 },
		{ -52.40, 48.01 }, { -52.37, 44.40 }, { -52.34, 40.79 },
		{ -52.31, 37.18 }, { -52.28, 33.57 }, { -52.28, 33.57 },
		{ -53.57, 31.40 }, { -54.86, 29.23 }, { -56.15, 27.06 },
		{ -57.45, 24.89 }, { -58.74, 22.72 }, { -60.03, 20.55 },
		{ -61.32, 18.38 }, { -62.61, 16.21 }, { -63.90, 14.04 },
		{ -65.19, 11.86 }, { -65.19, 11.86 }, { -68.18, 11.86 },
		{ -71.17, 11.86 }, { -74.17, 11.86 }, { -77.16, 11.86 },
		{ -80.15, 11.86 }, { -83.14, 11.86 }, { -86.13, 11.86 },
		{ -89.13, 11.86 }, { -92.12, 11.86 }, { -95.11, 11.86 },
		{ -95.11, 11.86 }, { -96.43, 12.92 }, { -97.75, 13.98 },
		{ -99.07, 15.03 }, { -100.39, 16.09 }, { -101.71, 17.14 }, { -103.03,
				18.20 }, { -104.35, 19.26 }, { -105.67, 20.31 }, { -106.99,
				21.37 }, { -108.31, 22.42 }, { -174.61, 11.86 }, { -177.34,
				11.92 }, { -180.07, 11.98 }, { -182.79, 12.04 }, { -185.52,
				12.10 }, { -188.25, 12.16 }, { -190.98, 12.22 }, { -193.71,
				12.28 }, { -196.43, 12.33 }, { -199.16, 12.39 }, { -201.89,
				12.45 }, { -201.89, 12.45 }, { -203.68, 13.89 }, { -205.47,
				15.33 }, { -207.26, 16.76 }, { -209.05, 18.20 }, { -210.84,
				19.64 }, { -212.63, 21.08 }, { -214.42, 22.51 }, { -216.21,
				23.95 }, { -218.00, 25.39 }, { -219.79, 26.83 }, { -219.79,
				26.83 }, { -217.88, 28.70 }, { -215.97, 30.58 }, { -214.07,
				32.46 }, { -212.16, 34.34 }, { -210.25, 36.21 }, { -208.34,
				38.09 }, { -206.44, 39.97 }, { -204.53, 41.84 }, { -202.62,
				43.72 }, { -200.72, 45.60 }, { -200.72, 45.60 }, { -198.58,
				45.63 }, { -196.43, 45.66 }, { -194.29, 45.69 }, { -192.15,
				45.72 }, { -190.01, 45.75 }, { -187.87, 45.78 }, { -185.73,
				45.81 }, { -183.59, 45.83 }, { -181.44, 45.86 }, { -179.30,
				45.89 }, { -199.84, 45.89 }, { -201.51, 46.92 }, { -203.18,
				47.95 }, { -204.85, 48.97 }, { -206.53, 50.00 }, { -208.20,
				51.03 }, { -209.87, 52.05 }, { -211.54, 53.08 }, { -213.21,
				54.11 }, { -214.89, 55.13 }, { -216.56, 56.16 }, { -216.56,
				56.16 }, { -216.53, 57.80 }, { -216.50, 59.45 }, { -216.47,
				61.09 }, { -216.44, 62.73 }, { -216.41, 64.37 }, { -216.38,
				66.02 }, { -216.35, 67.66 }, { -216.32, 69.30 }, { -216.29,
				70.95 }, { -216.27, 72.59 }, { -216.27, 72.59 }, { -214.65,
				73.41 }, { -213.04, 74.23 }, { -211.43, 75.05 }, { -209.81,
				75.87 }, { -208.20, 76.69 }, { -206.58, 77.52 }, { -204.97,
				78.34 }, { -203.36, 79.16 }, { -201.74, 79.98 }, { -200.13,
				80.80 }, { -200.13, 80.80 }, { -197.75, 80.74 }, { -195.38,
				80.68 }, { -193.00, 80.63 }, { -190.63, 80.57 }, { -188.25,
				80.51 }, { -185.87, 80.45 }, { -183.50, 80.39 }, { -181.12,
				80.33 }, { -178.75, 80.27 }, { -176.37, 80.22 },
		{ 32.50, 13.04 }, { 34.17, 14.88 }, { 35.84, 16.73 }, { 37.52, 18.58 },
		{ 39.19, 20.43 }, { 40.86, 22.28 }, { 42.53, 24.12 }, { 44.20, 25.97 },
		{ 45.88, 27.82 }, { 47.55, 29.67 }, { 49.22, 31.52 }, { 49.22, 31.52 },
		{ 49.31, 35.04 }, { 49.40, 38.56 }, { 49.48, 42.08 }, { 49.57, 45.60 },
		{ 49.66, 49.12 }, { 49.75, 52.64 }, { 49.84, 56.16 }, { 49.92, 59.68 },
		{ 50.01, 63.20 }, { 50.10, 66.72 }, { 50.10, 66.72 }, { 48.58, 68.68 },
		{ 47.05, 70.65 }, { 45.52, 72.62 }, { 44.00, 74.58 }, { 42.47, 76.55 },
		{ 40.95, 78.51 }, { 39.42, 80.48 }, { 37.90, 82.44 }, { 36.37, 84.41 },
		{ 34.85, 86.37 }, { 34.85, 86.37 }, { 33.23, 84.79 }, { 31.62, 83.21 },
		{ 30.01, 81.62 }, { 28.39, 80.04 }, { 26.78, 78.45 }, { 25.17, 76.87 },
		{ 23.55, 75.29 }, { 21.94, 73.70 }, { 20.33, 72.12 }, { 18.71, 70.53 },
		{ 18.71, 70.53 }, { 18.65, 66.54 }, { 18.60, 62.55 }, { 18.54, 58.56 },
		{ 18.48, 54.57 }, { 18.42, 50.59 }, { 18.36, 46.60 }, { 18.30, 42.61 },
		{ 18.24, 38.62 }, { 18.18, 34.63 }, { 18.13, 30.64 }, { 18.13, 30.64 },
		{ 19.56, 28.88 }, { 21.00, 27.12 }, { 22.44, 25.36 }, { 23.88, 23.60 },
		{ 25.31, 21.84 }, { 26.75, 20.08 }, { 28.19, 18.32 }, { 29.63, 16.56 },
		{ 31.06, 14.80 }, { 32.50, 13.04 }, { -160.82, 24.18 },
		{ -160.85, 29.76 }, { -160.88, 35.33 }, { -160.91, 40.90 }, { -160.94,
				46.48 }, { -160.97, 52.05 }, { -160.99, 57.63 }, { -161.02,
				63.20 }, { -161.05, 68.77 }, { -161.08, 74.35 }, { -161.11,
				79.92 }, { -161.11, 79.92 }, { -159.18, 80.74 }, { -157.24,
				81.56 }, { -155.30, 82.38 }, { -153.37, 83.21 }, { -151.43,
				84.03 }, { -149.50, 84.85 }, { -147.56, 85.67 }, { -145.62,
				86.49 }, { -143.69, 87.31 }, { -141.75, 88.13 }, { -141.75,
				88.13 }, { -139.67, 86.43 }, { -137.59, 84.73 }, { -135.50,
				83.03 }, { -133.42, 81.33 }, { -131.34, 79.63 }, { -129.25,
				77.93 }, { -127.17, 76.22 }, { -125.09, 74.52 }, { -123.01,
				72.82 }, { -120.92, 71.12 }, { -120.92, 71.12 }, { -120.92,
				66.51 }, { -120.92, 61.91 }, { -120.92, 57.30 }, { -120.92,
				52.70 }, { -120.92, 48.09 }, { -120.92, 43.49 }, { -120.92,
				38.88 }, { -120.92, 34.27 }, { -120.92, 29.67 }, { -120.92,
				25.06 }, { -120.92, 25.06 }, { -122.80, 23.74 }, { -124.68,
				22.42 }, { -126.56, 21.10 }, { -128.43, 19.78 }, { -130.31,
				18.46 }, { -132.19, 17.14 }, { -134.06, 15.82 }, { -135.94,
				14.50 }, { -137.82, 13.18 }, { -139.70, 11.86 }, { -139.70,
				11.86 }, { -141.81, 13.09 }, { -143.92, 14.33 }, { -146.03,
				15.56 }, { -148.15, 16.79 }, { -150.26, 18.02 }, { -152.37,
				19.26 }, { -154.48, 20.49 }, { -156.59, 21.72 }, { -158.71,
				22.95 }, { -160.82, 24.18 }, };
uint8_t button_run_prev = 0;
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_TIM1_Init(void);
static void MX_TIM2_Init(void);
static void MX_TIM4_Init(void);
static void MX_TIM5_Init(void);
static void MX_TIM3_Init(void);
static void MX_ADC1_Init(void);
static void MX_TIM16_Init(void);
static void MX_USART2_UART_Init(void);
static void MX_ADC2_Init(void);
static void MX_TIM8_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
 * @brief  The application entry point.
 * @retval int
 */
int main(void) {

	/* USER CODE BEGIN 1 */

	/* USER CODE END 1 */

	/* MCU Configuration--------------------------------------------------------*/

	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();

	/* USER CODE BEGIN Init */

	/* USER CODE END Init */

	/* Configure the system clock */
	SystemClock_Config();

	/* USER CODE BEGIN SysInit */

	/* USER CODE END SysInit */

	/* Initialize all configured peripherals */
	MX_GPIO_Init();
	MX_DMA_Init();
	MX_TIM1_Init();
	MX_TIM2_Init();
	MX_TIM4_Init();
	MX_TIM5_Init();
	MX_TIM3_Init();
	MX_ADC1_Init();
	MX_TIM16_Init();
	MX_USART2_UART_Init();
	MX_ADC2_Init();
	MX_TIM8_Init();
	/* USER CODE BEGIN 2 */
	hmodbus.huart = &huart2;
	hmodbus.htim = &htim16;
	hmodbus.slaveAddress = 0x15;
	hmodbus.RegisterSize = 70;
	Modbus_init(&hmodbus, &registerFrame);

	PID_POS_pris.Kp = Kp_pos_pris;
	PID_POS_pris.Ki = Ki_pos_pris;
	PID_POS_pris.Kd = Kd_pos_pris;
	arm_pid_init_f32(&PID_POS_pris, 0);

	PID_POS_re.Kp = Kp_pos_re;
	PID_POS_re.Ki = Ki_pos_re;
	PID_POS_re.Kd = Kd_pos_re;
	arm_pid_init_f32(&PID_POS_re, 0);

	MotorInit(&prismatic_motor, &htim1, TIM_CHANNEL_3, GPIOC, GPIO_PIN_7);
	MotorInit(&revolute_motor, &htim1, TIM_CHANNEL_2, GPIOC, GPIO_PIN_6);
	HAL_TIM_Base_Start(&htim8);
	HAL_TIM_PWM_Start(&htim8, TIM_CHANNEL_1);

	QEIInit(&prismatic_encoder, &htim4, 8192, 1000, 65536);
	QEIInit(&revolute_encoder, &htim3, 8192, 1000, 65536);

	PIDInit(&prismatic_vel_control, 65535, -65535);
	PIDInit(&revolute_vel_control, 65535, -65535);

	HAL_TIM_Base_Start_IT(&htim5);
	HAL_TIM_Base_Start_IT(&htim2);

	HAL_ADC_Start_DMA(&hadc1, JOY_RawRead, 20);
	HAL_ADC_Start_DMA(&hadc2, Prox_RawRead, 10);

//	MotorInit(&revolute_motor, &htim1, TIM_CHANNEL_1, GPIOB, GPIO_PIN_0);

//	registerFrame[4].U16 = 1;
//	registerFrame[5].U16 = 0;
	/* USER CODE END 2 */

	/* Infinite loop */
	/* USER CODE BEGIN WHILE */
	while (1) {
		/* USER CODE END WHILE */

		/* USER CODE BEGIN 3 */
		Modbus_Protocal_Worker();
	}
	/* USER CODE END 3 */
}

/**
 * @brief System Clock Configuration
 * @retval None
 */
void SystemClock_Config(void) {
	RCC_OscInitTypeDef RCC_OscInitStruct = { 0 };
	RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 };

	/** Configure the main internal regulator output voltage
	 */
	HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST);

	/** Initializes the RCC Oscillators according to the specified parameters
	 * in the RCC_OscInitTypeDef structure.
	 */
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
	RCC_OscInitStruct.HSIState = RCC_HSI_ON;
	RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
	RCC_OscInitStruct.PLL.PLLM = RCC_PLLM_DIV4;
	RCC_OscInitStruct.PLL.PLLN = 85;
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
	RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
	RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
		Error_Handler();
	}

	/** Initializes the CPU, AHB and APB buses clocks
	 */
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK
			| RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK) {
		Error_Handler();
	}
}

/**
 * @brief ADC1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_ADC1_Init(void) {

	/* USER CODE BEGIN ADC1_Init 0 */

	/* USER CODE END ADC1_Init 0 */

	ADC_MultiModeTypeDef multimode = { 0 };
	ADC_ChannelConfTypeDef sConfig = { 0 };

	/* USER CODE BEGIN ADC1_Init 1 */

	/* USER CODE END ADC1_Init 1 */

	/** Common config
	 */
	hadc1.Instance = ADC1;
	hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
	hadc1.Init.Resolution = ADC_RESOLUTION_12B;
	hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
	hadc1.Init.GainCompensation = 0;
	hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
	hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
	hadc1.Init.LowPowerAutoWait = DISABLE;
	hadc1.Init.ContinuousConvMode = ENABLE;
	hadc1.Init.NbrOfConversion = 2;
	hadc1.Init.DiscontinuousConvMode = DISABLE;
	hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
	hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
	hadc1.Init.DMAContinuousRequests = ENABLE;
	hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
	hadc1.Init.OversamplingMode = DISABLE;
	if (HAL_ADC_Init(&hadc1) != HAL_OK) {
		Error_Handler();
	}

	/** Configure the ADC multi-mode
	 */
	multimode.Mode = ADC_MODE_INDEPENDENT;
	if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK) {
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_7;
	sConfig.Rank = ADC_REGULAR_RANK_1;
	sConfig.SamplingTime = ADC_SAMPLETIME_640CYCLES_5;
	sConfig.SingleDiff = ADC_SINGLE_ENDED;
	sConfig.OffsetNumber = ADC_OFFSET_NONE;
	sConfig.Offset = 0;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK) {
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_8;
	sConfig.Rank = ADC_REGULAR_RANK_2;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN ADC1_Init 2 */

	/* USER CODE END ADC1_Init 2 */

}

/**
 * @brief ADC2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_ADC2_Init(void) {

	/* USER CODE BEGIN ADC2_Init 0 */

	/* USER CODE END ADC2_Init 0 */

	ADC_ChannelConfTypeDef sConfig = { 0 };

	/* USER CODE BEGIN ADC2_Init 1 */

	/* USER CODE END ADC2_Init 1 */

	/** Common config
	 */
	hadc2.Instance = ADC2;
	hadc2.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
	hadc2.Init.Resolution = ADC_RESOLUTION_12B;
	hadc2.Init.DataAlign = ADC_DATAALIGN_RIGHT;
	hadc2.Init.GainCompensation = 0;
	hadc2.Init.ScanConvMode = ADC_SCAN_DISABLE;
	hadc2.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
	hadc2.Init.LowPowerAutoWait = DISABLE;
	hadc2.Init.ContinuousConvMode = ENABLE;
	hadc2.Init.NbrOfConversion = 1;
	hadc2.Init.DiscontinuousConvMode = DISABLE;
	hadc2.Init.ExternalTrigConv = ADC_SOFTWARE_START;
	hadc2.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
	hadc2.Init.DMAContinuousRequests = ENABLE;
	hadc2.Init.Overrun = ADC_OVR_DATA_PRESERVED;
	hadc2.Init.OversamplingMode = DISABLE;
	if (HAL_ADC_Init(&hadc2) != HAL_OK) {
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_6;
	sConfig.Rank = ADC_REGULAR_RANK_1;
	sConfig.SamplingTime = ADC_SAMPLETIME_640CYCLES_5;
	sConfig.SingleDiff = ADC_SINGLE_ENDED;
	sConfig.OffsetNumber = ADC_OFFSET_NONE;
	sConfig.Offset = 0;
	if (HAL_ADC_ConfigChannel(&hadc2, &sConfig) != HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN ADC2_Init 2 */

	/* USER CODE END ADC2_Init 2 */

}

/**
 * @brief TIM1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM1_Init(void) {

	/* USER CODE BEGIN TIM1_Init 0 */

	/* USER CODE END TIM1_Init 0 */

	TIM_ClockConfigTypeDef sClockSourceConfig = { 0 };
	TIM_MasterConfigTypeDef sMasterConfig = { 0 };
	TIM_OC_InitTypeDef sConfigOC = { 0 };
	TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = { 0 };

	/* USER CODE BEGIN TIM1_Init 1 */

	/* USER CODE END TIM1_Init 1 */
	htim1.Instance = TIM1;
	htim1.Init.Prescaler = 169;
	htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim1.Init.Period = 19999;
	htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim1.Init.RepetitionCounter = 0;
	htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim1) != HAL_OK) {
		Error_Handler();
	}
	sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
	if (HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig) != HAL_OK) {
		Error_Handler();
	}
	if (HAL_TIM_PWM_Init(&htim1) != HAL_OK) {
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig)
			!= HAL_OK) {
		Error_Handler();
	}
	sConfigOC.OCMode = TIM_OCMODE_PWM1;
	sConfigOC.Pulse = 0;
	sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
	sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
	sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
	sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
	sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
	if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_2)
			!= HAL_OK) {
		Error_Handler();
	}
	if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_3)
			!= HAL_OK) {
		Error_Handler();
	}
	sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
	sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
	sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
	sBreakDeadTimeConfig.DeadTime = 0;
	sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
	sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
	sBreakDeadTimeConfig.BreakFilter = 0;
	sBreakDeadTimeConfig.BreakAFMode = TIM_BREAK_AFMODE_INPUT;
	sBreakDeadTimeConfig.Break2State = TIM_BREAK2_DISABLE;
	sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
	sBreakDeadTimeConfig.Break2Filter = 0;
	sBreakDeadTimeConfig.Break2AFMode = TIM_BREAK_AFMODE_INPUT;
	sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
	if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig)
			!= HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN TIM1_Init 2 */

	/* USER CODE END TIM1_Init 2 */
	HAL_TIM_MspPostInit(&htim1);

}

/**
 * @brief TIM2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM2_Init(void) {

	/* USER CODE BEGIN TIM2_Init 0 */

	/* USER CODE END TIM2_Init 0 */

	TIM_ClockConfigTypeDef sClockSourceConfig = { 0 };
	TIM_MasterConfigTypeDef sMasterConfig = { 0 };

	/* USER CODE BEGIN TIM2_Init 1 */

	/* USER CODE END TIM2_Init 1 */
	htim2.Instance = TIM2;
	htim2.Init.Prescaler = 169;
	htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim2.Init.Period = 999;
	htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim2) != HAL_OK) {
		Error_Handler();
	}
	sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
	if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK) {
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig)
			!= HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN TIM2_Init 2 */

	/* USER CODE END TIM2_Init 2 */

}

/**
 * @brief TIM3 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM3_Init(void) {

	/* USER CODE BEGIN TIM3_Init 0 */

	/* USER CODE END TIM3_Init 0 */

	TIM_Encoder_InitTypeDef sConfig = { 0 };
	TIM_MasterConfigTypeDef sMasterConfig = { 0 };

	/* USER CODE BEGIN TIM3_Init 1 */

	/* USER CODE END TIM3_Init 1 */
	htim3.Instance = TIM3;
	htim3.Init.Prescaler = 0;
	htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim3.Init.Period = 65535;
	htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	sConfig.EncoderMode = TIM_ENCODERMODE_TI12;
	sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;
	sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
	sConfig.IC1Prescaler = TIM_ICPSC_DIV1;
	sConfig.IC1Filter = 0;
	sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;
	sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
	sConfig.IC2Prescaler = TIM_ICPSC_DIV1;
	sConfig.IC2Filter = 0;
	if (HAL_TIM_Encoder_Init(&htim3, &sConfig) != HAL_OK) {
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig)
			!= HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN TIM3_Init 2 */

	/* USER CODE END TIM3_Init 2 */

}

/**
 * @brief TIM4 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM4_Init(void) {

	/* USER CODE BEGIN TIM4_Init 0 */

	/* USER CODE END TIM4_Init 0 */

	TIM_Encoder_InitTypeDef sConfig = { 0 };
	TIM_MasterConfigTypeDef sMasterConfig = { 0 };

	/* USER CODE BEGIN TIM4_Init 1 */

	/* USER CODE END TIM4_Init 1 */
	htim4.Instance = TIM4;
	htim4.Init.Prescaler = 0;
	htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim4.Init.Period = 65535;
	htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	sConfig.EncoderMode = TIM_ENCODERMODE_TI12;
	sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;
	sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
	sConfig.IC1Prescaler = TIM_ICPSC_DIV1;
	sConfig.IC1Filter = 0;
	sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;
	sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
	sConfig.IC2Prescaler = TIM_ICPSC_DIV1;
	sConfig.IC2Filter = 0;
	if (HAL_TIM_Encoder_Init(&htim4, &sConfig) != HAL_OK) {
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig)
			!= HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN TIM4_Init 2 */

	/* USER CODE END TIM4_Init 2 */

}

/**
 * @brief TIM5 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM5_Init(void) {

	/* USER CODE BEGIN TIM5_Init 0 */

	/* USER CODE END TIM5_Init 0 */

	TIM_ClockConfigTypeDef sClockSourceConfig = { 0 };
	TIM_MasterConfigTypeDef sMasterConfig = { 0 };

	/* USER CODE BEGIN TIM5_Init 1 */

	/* USER CODE END TIM5_Init 1 */
	htim5.Instance = TIM5;
	htim5.Init.Prescaler = 169;
	htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim5.Init.Period = 999;
	htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim5.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim5) != HAL_OK) {
		Error_Handler();
	}
	sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
	if (HAL_TIM_ConfigClockSource(&htim5, &sClockSourceConfig) != HAL_OK) {
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig)
			!= HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN TIM5_Init 2 */

	/* USER CODE END TIM5_Init 2 */

}

/**
 * @brief TIM8 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM8_Init(void) {

	/* USER CODE BEGIN TIM8_Init 0 */

	/* USER CODE END TIM8_Init 0 */

	TIM_ClockConfigTypeDef sClockSourceConfig = { 0 };
	TIM_MasterConfigTypeDef sMasterConfig = { 0 };
	TIM_OC_InitTypeDef sConfigOC = { 0 };
	TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = { 0 };

	/* USER CODE BEGIN TIM8_Init 1 */

	/* USER CODE END TIM8_Init 1 */
	htim8.Instance = TIM8;
	htim8.Init.Prescaler = 169;
	htim8.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim8.Init.Period = 19999;
	htim8.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim8.Init.RepetitionCounter = 0;
	htim8.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim8) != HAL_OK) {
		Error_Handler();
	}
	sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
	if (HAL_TIM_ConfigClockSource(&htim8, &sClockSourceConfig) != HAL_OK) {
		Error_Handler();
	}
	if (HAL_TIM_PWM_Init(&htim8) != HAL_OK) {
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim8, &sMasterConfig)
			!= HAL_OK) {
		Error_Handler();
	}
	sConfigOC.OCMode = TIM_OCMODE_PWM1;
	sConfigOC.Pulse = 0;
	sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
	sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
	sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
	sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
	sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
	if (HAL_TIM_PWM_ConfigChannel(&htim8, &sConfigOC, TIM_CHANNEL_1)
			!= HAL_OK) {
		Error_Handler();
	}
	sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
	sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
	sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
	sBreakDeadTimeConfig.DeadTime = 0;
	sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
	sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
	sBreakDeadTimeConfig.BreakFilter = 0;
	sBreakDeadTimeConfig.BreakAFMode = TIM_BREAK_AFMODE_INPUT;
	sBreakDeadTimeConfig.Break2State = TIM_BREAK2_DISABLE;
	sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
	sBreakDeadTimeConfig.Break2Filter = 0;
	sBreakDeadTimeConfig.Break2AFMode = TIM_BREAK_AFMODE_INPUT;
	sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
	if (HAL_TIMEx_ConfigBreakDeadTime(&htim8, &sBreakDeadTimeConfig)
			!= HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN TIM8_Init 2 */

	/* USER CODE END TIM8_Init 2 */
	HAL_TIM_MspPostInit(&htim8);

}

/**
 * @brief TIM16 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM16_Init(void) {

	/* USER CODE BEGIN TIM16_Init 0 */

	/* USER CODE END TIM16_Init 0 */

	/* USER CODE BEGIN TIM16_Init 1 */

	/* USER CODE END TIM16_Init 1 */
	htim16.Instance = TIM16;
	htim16.Init.Prescaler = 169;
	htim16.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim16.Init.Period = 1145;
	htim16.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim16.Init.RepetitionCounter = 0;
	htim16.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim16) != HAL_OK) {
		Error_Handler();
	}
	if (HAL_TIM_OnePulse_Init(&htim16, TIM_OPMODE_SINGLE) != HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN TIM16_Init 2 */

	/* USER CODE END TIM16_Init 2 */

}

/**
 * @brief USART2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_USART2_UART_Init(void) {

	/* USER CODE BEGIN USART2_Init 0 */

	/* USER CODE END USART2_Init 0 */

	/* USER CODE BEGIN USART2_Init 1 */

	/* USER CODE END USART2_Init 1 */
	huart2.Instance = USART2;
	huart2.Init.BaudRate = 115200;
	huart2.Init.WordLength = UART_WORDLENGTH_9B;
	huart2.Init.StopBits = UART_STOPBITS_1;
	huart2.Init.Parity = UART_PARITY_EVEN;
	huart2.Init.Mode = UART_MODE_TX_RX;
	huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
	huart2.Init.OverSampling = UART_OVERSAMPLING_16;
	huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
	huart2.Init.ClockPrescaler = UART_PRESCALER_DIV1;
	huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
	if (HAL_UART_Init(&huart2) != HAL_OK) {
		Error_Handler();
	}
	if (HAL_UARTEx_SetTxFifoThreshold(&huart2, UART_TXFIFO_THRESHOLD_1_8)
			!= HAL_OK) {
		Error_Handler();
	}
	if (HAL_UARTEx_SetRxFifoThreshold(&huart2, UART_RXFIFO_THRESHOLD_1_8)
			!= HAL_OK) {
		Error_Handler();
	}
	if (HAL_UARTEx_DisableFifoMode(&huart2) != HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN USART2_Init 2 */

	/* USER CODE END USART2_Init 2 */

}

/**
 * Enable DMA controller clock
 */
static void MX_DMA_Init(void) {

	/* DMA controller clock enable */
	__HAL_RCC_DMAMUX1_CLK_ENABLE();
	__HAL_RCC_DMA1_CLK_ENABLE();

	/* DMA interrupt init */
	/* DMA1_Channel1_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
	/* DMA1_Channel2_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel2_IRQn);
	/* DMA1_Channel3_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel3_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel3_IRQn);
	/* DMA1_Channel4_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel4_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel4_IRQn);

}

/**
 * @brief GPIO Initialization Function
 * @param None
 * @retval None
 */
static void MX_GPIO_Init(void) {
	GPIO_InitTypeDef GPIO_InitStruct = { 0 };
	/* USER CODE BEGIN MX_GPIO_Init_1 */

	/* USER CODE END MX_GPIO_Init_1 */

	/* GPIO Ports Clock Enable */
	__HAL_RCC_GPIOC_CLK_ENABLE();
	__HAL_RCC_GPIOF_CLK_ENABLE();
	__HAL_RCC_GPIOA_CLK_ENABLE();
	__HAL_RCC_GPIOB_CLK_ENABLE();

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_6 | GPIO_PIN_7 | GPIO_PIN_10,
			GPIO_PIN_RESET);

	/*Configure GPIO pin : PC13 */
	GPIO_InitStruct.Pin = GPIO_PIN_13;
	GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

	/*Configure GPIO pins : PC3 PC9 */
	GPIO_InitStruct.Pin = GPIO_PIN_3 | GPIO_PIN_9;
	GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

	/*Configure GPIO pins : RUN_Joy_Pin Save_Joy_Pin */
	GPIO_InitStruct.Pin = RUN_Joy_Pin | Save_Joy_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_PULLUP;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

	/*Configure GPIO pin : PA4 */
	GPIO_InitStruct.Pin = GPIO_PIN_4;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

	/*Configure GPIO pin : LD2_Pin */
	GPIO_InitStruct.Pin = LD2_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);

	/*Configure GPIO pins : PB11 PB12 */
	GPIO_InitStruct.Pin = GPIO_PIN_11 | GPIO_PIN_12;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

	/*Configure GPIO pins : PB13 PB14 */
	GPIO_InitStruct.Pin = GPIO_PIN_13 | GPIO_PIN_14;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

	/*Configure GPIO pins : PC6 PC7 PC10 */
	GPIO_InitStruct.Pin = GPIO_PIN_6 | GPIO_PIN_7 | GPIO_PIN_10;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

	/*Configure GPIO pin : PC12 */
	GPIO_InitStruct.Pin = GPIO_PIN_12;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

	/* EXTI interrupt init*/
	HAL_NVIC_SetPriority(EXTI3_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(EXTI3_IRQn);

	HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);

	/* USER CODE BEGIN MX_GPIO_Init_2 */

	/* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */
void Prismatic_CasCadeControl() {
	float setpoint_pris_abs = Trapezoidal_GetCurrentAbsolute(&prisProfile);

	error_pos_pris = setpoint_pris_abs - (float) ball_screw_pos;
	output_pos_pris = arm_pid_f32(&PID_POS_pris, error_pos_pris);

	if (output_pos_pris > 550) {
		output_pos_pris = 550;
	} else if (output_pos_pris < -550) {
		output_pos_pris = -550;
	}

	error_velo_pris = output_pos_pris - ball_screw_vel;
	output_velo_pris = PIDCompute(&prismatic_vel_control, Kp_velo_pris,
			Ki_velo_pris, Kd_velo_pris, error_velo_pris);

	if (limit_r == 1 && output_prismatic < 0) {
		output_prismatic = 0;
	} else if (limit_l == 1 && output_prismatic > 0) {
		output_prismatic = 0;
	}

	// Motor control}
	if (error_pos_pris <= 0.1 && error_pos_pris >= -0.1) {
		output_prismatic = 0;
	} else {
		output_prismatic = output_velo_pris;
	}
}

void Revolute_CasCadeControl() {
	float setpoint_rev_abs = Trapezoidal_GetCurrentAbsolute(&revProfile);
	error_pos_re = setpoint_rev_abs - revolute_encoder.rads;
	output_pos_re = arm_pid_f32(&PID_POS_re, error_pos_re);

	if (output_pos_re > 300) {
		output_pos_re = 300;
	} else if (output_pos_re < -300) {
		output_pos_re = -300;
	}

	error_velo_re = output_pos_re - (revolute_encoder.radps / 2);

	output_velo_re = PIDCompute(&revolute_vel_control, Kp_velo_re, Ki_velo_re,
			Kd_velo_re, error_velo_re);

	if (revolute_flag == 1 && output_revolute > 0) {
		output_revolute = 0;
	} else if (revolute_encoder.rads >= (2 * M_PI) && output_revolute < 0) {
		output_revolute = 0;
	}
	// Motor control
	if (error_pos_re <= 0.0035 && error_pos_re >= -0.0035) {
		output_revolute = 0;
	} else {
		output_revolute = output_velo_re;
	}
}

void ball_screw_converter() {
	ball_screw_pos = (prismatic_encoder.rads * (16.00f / (2.0f * M_PI)));
	ball_screw_vel = prismatic_radps_lowpass * (16.0f / (2.0f * M_PI));
}

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
	if (GPIO_Pin == GPIO_PIN_13) {
		current_state = STATE_ERROR;
		registerFrame[1].U16 = STATUS_IDLE;
	}
}

long map(long x, long in_min, long in_max, long out_min, long out_max) {
	return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

float mapf(float x, float in_min, float in_max, float out_min, float out_max) {
	return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {

	// sensor timer 1000 hz
	if (htim == &htim2) {
		HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);
//		MotorSet(&revolute_motor, 1000, 65535);
		QEIPosVelUpdate(&prismatic_encoder);
		QEIPosVelUpdate(&revolute_encoder);
		//Limit Switch check
		limit_l = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_11);
		limit_r = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_12);
		limit_plot = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_13);
		//Joy Calculate

		// filter
		int32_t sum_x = 0, sum_y = 0;
		for (int i = 0; i < 20; i++) {
			if ((i & 1) == 0)
				sum_y += JOY_RawRead[i];
			else
				sum_x += JOY_RawRead[i];
		}

		int32_t raw_x = sum_x / 10;
		int32_t raw_y = sum_y / 10;

		if (raw_x < 1700 && raw_x > 1500) {
			raw_x = 3400 / 2;
		}
		if (raw_y < 1700 && raw_y > 1500) {
			raw_y = 3400 / 2;
		}

		Joy_x = map(raw_x, RAW_MIN, RAW_MAX, OUT_MIN, OUT_MAX);
		Joy_y = map(raw_y, RAW_MIN, RAW_MAX, OUT_MIN, OUT_MAX);

		// Joy button
//		Joy_run = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0);
//		Joy_save = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_1);

		//Prismatic Low pass filter
		prismatic_radps_lowpass = prismatic_radps_lowpass_prev
				+ alpha
						* (prismatic_encoder.radps
								- prismatic_radps_lowpass_prev);

		prismatic_acceleration = ((prismatic_radps_lowpass
				- prismatic_radps_lowpass_prev) / dt);
		prismatic_radps_lowpass_prev = prismatic_radps_lowpass;
		prismatic_acceleration_lowpass = prismatic_acceleration_lowpass_prev
				+ alpha
						* (prismatic_acceleration
								- prismatic_acceleration_lowpass_prev);
		ball_screw_converter();

		// ==== Revolute Low‐Pass Filter ====
		// 1) กรองความเร็ว (rad/s) ของแกน Revolute
		revolute_radps_lowpass =
				revolute_radps_lowpass_prev
						+ alpha
								* (revolute_encoder.radps
										- revolute_radps_lowpass_prev);
		// 2) คำนวณอัตราเร่งดิบ (rad/s^2) จากความเปลี่ยนแปลงของค่าที่กรองแล้ว
		revolute_acceleration = (revolute_radps_lowpass
				- revolute_radps_lowpass_prev) / dt;
		// 3) กรองอัตราเร่งให้ลื่น (หากต้องการใช้ค่าเร่งหลังกรอง)
		revolute_acceleration_lowpass = revolute_acceleration_lowpass_prev
				+ alpha
						* (revolute_acceleration
								- revolute_acceleration_lowpass_prev);
		// 4) เก็บสถานะย้อนกลับไว้ใช้รอบถัดไป
		revolute_radps_lowpass_prev = revolute_radps_lowpass;
		revolute_acceleration_lowpass_prev = revolute_acceleration_lowpass;

		// Prox shimttrigger
//		revolute_flag = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4);
		if (Prox_RawRead[0] > 3000) {
			revolute_flag = 0;
		} else if (Prox_RawRead[0] < 1500) {
			revolute_flag = 1;
		}

		//Servo
		if (registerFrame[4].U16 == 1) {
			__HAL_TIM_SET_COMPARE(&htim8, TIM_CHANNEL_1, 1600);
		} else if (registerFrame[5].U16 == 1) {
			__HAL_TIM_SET_COMPARE(&htim8, TIM_CHANNEL_1, 2200);
		}
//		__HAL_TIM_SET_COMPARE(&htim8, TIM_CHANNEL_1, motor_voltage);
		//button
		Joy_save = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_13);
		Joy_run = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_14);
		button_emer =
				(HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13) == GPIO_PIN_SET) ? 1 : 0;

		button_reset =
				(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_13) == GPIO_PIN_SET
						&& button_emer == 1) ? 1 : 0;

		button_run =
				(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_14) == GPIO_PIN_SET
						&& button_emer) ? 1 : 0;

		MotorSet(&prismatic_motor, 1000, output_prismatic);
		MotorSet(&revolute_motor, 1000, output_revolute);

		// Protocal
		// Heart beat protocal 0.5 sec
		if (heartbeat_counter > 500) {
			heartbeat_counter = 0;
			registerFrame[0x00].U16 =
					(registerFrame[0X00].U16 == 0) ? 22881 : 0;
		}
		heartbeat_counter++;
	}

	// state timer 1000 hz
	if (htim == &htim5) {

		registerFrame[11].U16 = (int) (300.0 - (ball_screw_pos * 10));
		registerFrame[12].U16 = (int) (revolute_encoder.rads * (18 / 2 * M_PI)
				* 10);
		registerFrame[13].U16 = (int) (ball_screw_vel * 10);
		registerFrame[14].U16 = (int) (revProfile.current_velocity
				* (180 / 2 * M_PI) * 10);
		registerFrame[15].U16 = (int) (prismatic_acceleration_lowpass * 10);
		registerFrame[16].U16 = (int) (revolute_acceleration_lowpass * 10);

		// ตรวจสอบคำสั่งหยุดฉุกเฉิน (มีความสำคัญสูงสุด)
		if (registerFrame[1].U16 & STATUS_STOP) {
			current_state = STATE_STOPPING;
		}
		if ((registerFrame[1].U16 & STATUS_HOME) && pain_flang == 0) {
			current_state = STATE_HOMING;
		} else if ((registerFrame[1].U16 & STATUS_JOG) && running_flang == 0) {
			current_state = STATE_JOGGING;
			registerFrame[10].U16 = STATUS_JOG;
		} else if (registerFrame[1].U16 & STATUS_POINT) {
			current_state = STATE_POINT_MOVING;
			pointMoveNeedsInit = 1;
			registerFrame[10].U16 = STATUS_POINT;
		} else if (registerFrame[1].U16 & STATUS_GO_TO_TARGET) {
			current_state = STATE_GO_TO_TARGET;
			registerFrame[10].U16 = STATUS_GO_TO_TARGET;
		} else if (registerFrame[1].U16 & STATUS_IDLE) {
			current_state = STATE_IDLE;
		} else if (registerFrame[1].U16 & STATUS_TEST) {
			current_state = STATE_TEST;
		}

		if (registerFrame[4].U16 == 1 && registerFrame[5].U16 == 0) {
			//Pen Up Servo On
			registerFrame[3].U16 = 1 << 0;
		} else {
			//Pen Doen Servo Off
			registerFrame[3].U16 = 1 << 1;
		}

		if (button_reset == 1
				&& (current_state == STATE_ERROR || current_state == STATE_IDLE)
				&& button_emer == 1) {
			registerFrame[1].U16 = STATUS_HOME;
		}

		switch (current_state) {
		case STATE_HOMING:

			if (pen_flag == 0) {
				pen_flag = 1;
				count_time = 0;
			}

			if (count_time <= 1500) {
				output_prismatic = 0;
				output_revolute = 0;
				registerFrame[4].U16 = 1;
				registerFrame[5].U16 = 0;
				count_time++;
			} else {
				if (limit_r != 1) {
					output_prismatic = -(65535 / 2.0);
				} else if (limit_r == 1) {
					limit_l_prev = 1;
					output_prismatic = 0;
					QEI_Reset(&prismatic_encoder);
					QEIInit(&prismatic_encoder, &htim4, 8192, 1000, 65536);
				}
				if (revolute_flag != 1) {
					output_revolute = -60000;
				} else if (revolute_flag == 1) {
					revolute_homed = 1; // Check Proximity trick
					output_revolute = 0;
					QEI_Reset(&revolute_encoder);
					QEIInit(&revolute_encoder, &htim3, 8192, 1000, 65536);
				}

				registerFrame[11].U16 = 0;
				registerFrame[12].U16 = 0;
				registerFrame[13].U16 = 0;
				registerFrame[14].U16 = 0;
				registerFrame[15].U16 = 0;
				registerFrame[16].U16 = 0;

				target_position_prismatic = 0;
				target_position_revolute = 0;
				error_pos_re = 0;
				error_pos_pris = 0;
				registerFrame[10].U16 = STATUS_HOME;
				if (button_run == 1) {
					current_state = STATE_PAIN;
					pain_flang = 1;
				}
			}
			break;
		case STATE_PAIN:
			// ถ้าวิ่งจนครบทุกจุด ให้ข้ามไปโฮมมิ่ง
			if (path_idx >= PATH_POINTS) {
				registerFrame[4].U16 = 1;
				registerFrame[5].U16 = 0;
				pain_flang = 0;
				current_state = STATE_HOMING;
				break;
			}

			if (painInit) {
				Kp_pos_re = 15.0;
				Ki_pos_re = 0.0;         //8.5;
				Kd_pos_re = 2.0;

				Kp_velo_re = 3000.0;
				Ki_velo_re = 0.2;         //8.5;
				Kd_velo_re = 0.0;
				float x_mm = path[path_idx][0];
				float y_mm = path[path_idx][1];

				if (x_mm == -1 && y_mm == -1) {
					path_idx++;
				} else {
					registerFrame[4].U16 = 0;
					registerFrame[5].U16 = 1;
				}

				theta = atan2(y_mm, x_mm);
				if (theta < 0.0f)
					theta += 2.0f * M_PI;

				theta *= 2.0;

				if (theta <= 2.0 * M_PI) {
					target_position_revolute = theta;
					target_position_prismatic = 300
							+ (sqrt((x_mm * x_mm) + (y_mm * y_mm)));
				} else if (theta > 2.0 * M_PI) {
					target_position_revolute = (float) (fabs(M_PI - theta));
					target_position_prismatic = mapf(
							sqrt((x_mm * x_mm) + (y_mm * y_mm)), -300, 0, 300,
							600);
				}

				Trapezoidal_Init(&prisProfile, (float) ball_screw_pos,
						target_position_prismatic, 550.0f, 250.0f);
				Trapezoidal_Init(&revProfile, revolute_encoder.rads,
						target_position_revolute, 2.0f, 0.4f);

				painInit = 0;
			}

			if (!prisProfile.finished)
				Trapezoidal_Update(&prisProfile, dt);
			if (!revProfile.finished)
				Trapezoidal_Update(&revProfile, dt);
			Prismatic_CasCadeControl();
			Revolute_CasCadeControl();

			if ((limit_r && output_prismatic < 0)
					|| (limit_l && output_prismatic > 0))
				output_prismatic = 0;
			if ((revolute_flag && output_revolute < 0)
					|| (revolute_encoder.rads >= 2.0f * M_PI
							&& output_revolute > 0))
				output_revolute = 0;

			if (prisProfile.finished && revProfile.finished) {
//			if (prisProfile.finished && revProfile.finished
//					&& output_prismatic == 0 && output_revolute == 0) {
//				registerFrame[4].U16 = 0;
//				registerFrame[5].U16 = 1;
				path_idx++;
				painInit = 1;
			}
			break;
		case STATE_JOGGING:
			//Call joystick mode
//			registerFrame[4].U16 = 1;
//			registerFrame[5].U16 = 0;
//			joy_flag = 1;

			if (limit_r == 1) {
				output_prismatic = 0;
//				QEI_Reset(&prismatic_encoder);
//				QEIInit(&prismatic_encoder, &htim4, 8192, 1000, 65536);
			}

			if (revolute_flag == 1) {
				output_revolute = 0;
//				QEI_Reset(&revolute_encoder);
//				QEIInit(&revolute_encoder, &htim3, 8192, 1000, 65536);
			}

			output_prismatic = (Joy_x / 100.0) * 20000;

			if (limit_r == 1 && output_prismatic < 0) {
				output_prismatic = 0;
			} else if (limit_l == 1 && output_prismatic > 0) {
				output_prismatic = 0;
			}

			output_revolute = (Joy_y / 100.0) * 30000.0;

			if (revolute_flag == 1 && output_revolute < 0) {
				output_revolute = 0;
			} else if (revolute_encoder.rads >= (2 * M_PI)
					&& output_revolute > 0) {
				output_revolute = 0;
			}

			if (button_reset == 1) {
				count_run = 0;
				current_state = STATE_RUNING;
				pointRunNeedsInit = 1;
				running_flang = 1;
//				registerFrame[4].U16 = 1;
//				registerFrame[5].U16 = 0;
			}

			if (button_run == 1 && button_run_prev == 0) {
				if (count >= 0 && count < 10) {
					registerFrame[20 + count * 2].U16 = ball_screw_pos * 10;
					registerFrame[21 + count * 2].U16 = (revolute_encoder.rads
							/ (2 * M_PI)) * 1800.0;

					ten_point[count][0] = (float) ball_screw_pos;
					ten_point[count][1] = (float) revolute_encoder.rads;

//					registerFrame[18 + count * 2].U16 = (float) ball_screw_pos;
//					registerFrame[19 + count * 2].U16 =
//							(float) revolute_encoder.rads;
				} else {
					count = 0;
				}
				count++;
			}

			pen_flag = 0;
			break;
		case STATE_RUNING:

			if (pointRunNeedsInit == 1) {
				registerFrame[4].U16 = 1;
				registerFrame[5].U16 = 0;

				target_position_prismatic = (float) (ten_point[count_run][0]);
				target_position_revolute = (float) (ten_point[count_run][1]);

				count_run++;

				float abs_start_pris = (float) ball_screw_pos;
				float abs_goal_pris = target_position_prismatic;  // (mm)

				Trapezoidal_Init(&prisProfile, abs_start_pris, abs_goal_pris,
						550.0f, // v_max (mm/s)
						250.0f); // a_max (mm/s²)

				float abs_start_rev = (float) revolute_encoder.rads;
				float abs_goal_rev = target_position_revolute/* from registerFrame[65], converted to radians */;

				Trapezoidal_Init(&revProfile, abs_start_rev, abs_goal_rev, 2.0f, // v_max (rad/s)
						0.4f); // a_max (rad/s²)
				pointRunNeedsInit = 0;
			}

			if (!prisProfile.finished) {
				Trapezoidal_Update(&prisProfile, 0.001f);
			}
			if (!revProfile.finished) {
				Trapezoidal_Update(&revProfile, 0.001f);
			}

			if (output_prismatic == 0 && output_revolute == 0
					&& prisProfile.finished && revProfile.finished) {

				if (ten_flag == 0) {
					ten_flag = 1;
					ten_count = 0;

				} else {
					if (ten_count <= 1500) {
						registerFrame[4].U16 = 0;
						registerFrame[5].U16 = 1;
						output_prismatic = 0;
						output_revolute = 0;
						ten_count++;
					} else if (ten_count <= 3000) {
						registerFrame[4].U16 = 0;
						registerFrame[5].U16 = 1;
					} else {
						pointRunNeedsInit = 1;
						ten_flag = 0;
					}
				}

			} else {

				Revolute_CasCadeControl();
				Prismatic_CasCadeControl();

				if (limit_r == 1 && limit_l_prev == 0) {
					output_prismatic = 0;
				}

				if (revolute_flag == 1 && revolute_homed == 0) {
					output_revolute = 0;
				}

			}

//			if (button_reset && !button_reset_prev) {
////				count_run++;
//				pointRunNeedsInit = 1;
//			}
//
			if (button_run == 1 || count_run > count) {
				running_flang = 0;
				current_state = STATE_JOGGING;
				count_run = 0;
			}
			pen_flag = 0;
			break;
		case STATE_POINT_MOVING:
//			registerFrame[4].U16 = 1;
//			registerFrame[5].U16 = 0;
			theta = (float) (registerFrame[65].U16);
			if (theta <= 1800) {
				target_position_revolute = (float) (registerFrame[65].U16
						/ 1800.0) * (2.0 * M_PI);
				target_position_prismatic = 300 - (registerFrame[64].U16 / 10);
			} else if (theta >= 1800) {
				target_position_revolute = (float) (fabs(
						180 - registerFrame[65].U16 / 10.0));
				target_position_revolute = (float) (target_position_revolute
						/ 180.0) * (2.0 * M_PI);
				target_position_prismatic = mapf((registerFrame[64].U16 / 10),
						0, 300, 300, 600);
			}
			if (pointMoveNeedsInit) {
				float abs_start_pris = (float) ball_screw_pos;
				float abs_goal_pris = target_position_prismatic;

				Trapezoidal_Init(&prisProfile, abs_start_pris, abs_goal_pris,
						550.0f, 250.0f);

				float abs_start_rev = (float) revolute_encoder.rads;
				float abs_goal_rev = target_position_revolute;

				Trapezoidal_Init(&revProfile, abs_start_rev, abs_goal_rev, 2.0f, // v_max (rad/s)
						0.4f); // a_max (rad/s²)

				pointMoveNeedsInit = 0;
			}
			pen_flag = 0;
			break;
		case STATE_GO_TO_TARGET:

			if (!prisProfile.finished) {
				Trapezoidal_Update(&prisProfile, 0.001f);
			}
			if (!revProfile.finished) {
				Trapezoidal_Update(&revProfile, 0.001f);
			}

			Revolute_CasCadeControl();
			Prismatic_CasCadeControl();

			if (limit_r == 1 && limit_l_prev == 0) {
				output_prismatic = 0;
				QEI_Reset(&prismatic_encoder);
				QEIInit(&prismatic_encoder, &htim4, 8192, 1000, 65536);
			}

			if (revolute_flag == 1 && revolute_homed == 0) {
				output_revolute = 0;
				QEI_Reset(&revolute_encoder);
				QEIInit(&revolute_encoder, &htim3, 8192, 1000, 65536);
			}
//			registerFrame[11].U16 = (int) (ball_screw_pos * 10);
//			registerFrame[12].U16 = (int) (revolute_encoder.rads * (180 / 2 * M_PI)
//					* 10);
//			registerFrame[13].U16 = (int) (ball_screw_vel * 10);
//			registerFrame[14].U16 = (int) (revProfile.current_velocity * (180 / 2 * M_PI)
//					* 10);
//			registerFrame[15].U16 = (int) (prismatic_acceleration_lowpass * 10);
//			registerFrame[16].U16 = (int) (revolute_acceleration_lowpass * 10);

			if (output_prismatic == 0 && output_revolute == 0
					&& prisProfile.finished && revProfile.finished) {
				registerFrame[1].U16 = STATUS_STOP;
			}
//			if (prisProfile.finished && revProfile.finished && output_prismatic == 0 ) {
//				registerFrame[1].U16 = STATUS_STOP;
//			}
			pen_flag = 0;
			break;

		case STATE_STOPPING:
			registerFrame[10].U16 = STATUS_STOP;
			revolute_homed = 0;
			limit_l_prev = 0;
			output_revolute = 0;
			output_prismatic = 0;
//			registerFrame[4].U16 = 0;
//			registerFrame[5].U16 = 1;
			pen_flag = 0;
			break;

		case STATE_ERROR:
			//when emergency trick
			output_revolute = 0;
			output_prismatic = 0;
//			registerFrame[4].U16 = 0;
//			registerFrame[5].U16 = 1;
			pen_flag = 0;
			pain_flang = 0;
			break;
		case STATE_TEST:
			if (limit_r == 1) {
				output_prismatic = 0;
				QEI_Reset(&prismatic_encoder);
				QEIInit(&prismatic_encoder, &htim4, 8192, 1000, 65536);
			}

			if (revolute_flag == 1) {
				output_revolute = 0;
				QEI_Reset(&revolute_encoder);
				QEIInit(&revolute_encoder, &htim3, 8192, 1000, 65536);
			}

			output_prismatic = (Joy_x / 100.0) * 65535.0;

			if (limit_r == 1 && output_prismatic < 0) {
				output_prismatic = 0;
			} else if (limit_l == 1 && output_prismatic > 0) {
				output_prismatic = 0;
			}

			output_revolute = (Joy_y / 100.0) * 65535.0;

			if (revolute_flag == 1 && output_revolute < 0) {
				output_revolute = 0;
			} else if (revolute_encoder.rads >= (2 * M_PI)
					&& output_revolute > 0) {
				output_revolute = 0;
			}

			pen_flag = 0;
			break;
		}
		button_reset_prev = button_reset;
		button_run_prev = button_run;
	}
}
/* USER CODE END 4 */

/**
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void Error_Handler(void) {
	/* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */
	__disable_irq();
	while (1) {
	}
	/* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
