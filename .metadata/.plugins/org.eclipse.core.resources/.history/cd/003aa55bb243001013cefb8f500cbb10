/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file           : main.c
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "motor.h"
#include "arm_math.h"
#include "QEI.h"
#include "PID.h"
#include "Kalman.h"
#include "ModBusRTU.h"
#include "math.h"
#include "Trapezoidal.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
#define PRISM_UPDATE_THRESH 40.0f
// LOW PASS cutoff frequency
#define FC   5.0f
#define VELOCITY_DEADZONE   0.01f   // ปรับตามหน่วย rads/s หรือ mm/s ที่เหมาะสม
//Joy set origin
#define RAW_MIN    0    // e.g. you saw ~20 at one end
#define RAW_CENTER 1750  // you measured ~1700–1800 at rest
#define RAW_MAX   3400   // you saw ~4080 at the other end
#define OUT_MIN  -100
#define OUT_MAX  +100
#define PATH_POINTS  (sizeof(path)/sizeof(path[0]))
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;
ADC_HandleTypeDef hadc2;
DMA_HandleTypeDef hdma_adc1;
DMA_HandleTypeDef hdma_adc2;

TIM_HandleTypeDef htim1;
TIM_HandleTypeDef htim2;
TIM_HandleTypeDef htim3;
TIM_HandleTypeDef htim4;
TIM_HandleTypeDef htim5;
TIM_HandleTypeDef htim8;
TIM_HandleTypeDef htim16;

UART_HandleTypeDef huart2;
DMA_HandleTypeDef hdma_usart2_rx;
DMA_HandleTypeDef hdma_usart2_tx;

/* USER CODE BEGIN PV */
// Velo profile
VELO_PROFILE prisProfile;
VELO_PROFILE revProfile;

ModbusHandleTypedef hmodbus;
volatile u16u8_t registerFrame[70];
//state machine
typedef enum {
	STATUS_IDLE = 0, STATUS_HOME = 1 << 0,        // 00001 = 1 - สถานะโฮมมิ่ง
	STATUS_JOG = 1 << 1,         // 00010 = 2 - สถานะจ็อกกิ้ง
	STATUS_POINT = 1 << 2,       // 00100 = 4 - สถานะเคลื่อนที่แบบจุดต่อจุด
	STATUS_GO_TO_TARGET = 1 << 3,       // 01000 = 8 - สถานะไปยังตำแหน่งเป้าหมาย
	STATUS_STOP = 1 << 4         // 10000 = 16 - สถานะหยุดฉุกเฉิน
} MovingStatusFlags;

typedef enum {
	STATE_IDLE,
	STATE_HOMING,
	STATE_JOGGING,
	STATE_POINT_MOVING,
	STATE_GO_TO_TARGET,
	STATE_STOPPING,
	STATE_ERROR,
	STATE_RUNING,
	STATE_PAIN
} RobotState;

typedef enum {
	SERVO_STATE,
} Servo_state;

RobotState current_state = STATE_IDLE;
int joy_flag = 0;
int point_flag = 0;
float joy_save[10];

MOTOR prismatic_motor;
MOTOR revolute_motor;
MOTOR servo_motor;

float target_position_prismatic = 0.0;

// PID_Velocity gain
float Kp_velo_pris = 100.0;
float Ki_velo_pris = 2.0;      //8.5;
float Kd_velo_pris = 0.0;
float output_velo_pris = 0.00;
float error_velo_pris = 0.00;

// PID_Position gain
//float Kp_pos = 4.5; encoder
float Kp_pos_pris = 6.0;
float Ki_pos_pris = 0.0;
float Kd_pos_pris = 0.0;
float output_pos_pris = 0.00;
float error_pos_pris = 0.00;

//PID_Position CMSIS
arm_pid_instance_f32 PID_POS_pris = { 0 };
arm_pid_instance_f32 PID_POS_re = { 0 };

int32_t setpoint = 0;
float output_prismatic = 0;
float output_revolute = 0;

QEI prismatic_encoder;
CONTROLLER prismatic_pos_control;
CONTROLLER prismatic_vel_control;

// Prismatic low-pass
// LOW Pass filter
const float dt = 0.001f;
const float RC = 1.0f / (2.0f * 3.1415926f * FC);
const float alpha = dt / (RC + dt);
float prismatic_radps_lowpass_prev = 0.0f;  // filter state
float prismatic_radps_lowpass = 0.0f;

// Acceleration
float prismatic_acceleration = 0.0f;
float prismatic_acceleration_lowpass = 0.0f;
float prismatic_acceleration_lowpass_prev = 0.0f;

// unit converter
double ball_screw_pos;
double ball_screw_vel;

//REvolute
float target_position_revolute = 0.0;

QEI revolute_encoder;
uint8_t revolute_flag = 0;
CONTROLLER revolute_pos_control;
CONTROLLER revolute_vel_control;

// unit converter
uint8_t limit_r = 0;
uint8_t limit_r_prev = 0;
uint8_t limit_l = 0;
uint8_t limit_l_prev = 0;
uint8_t limit_plot = 0;

float motor_voltage = 0.0;
float error_rads = 0.0;

// PID_Velocity gain
float Kp_pos_re = 15.0;
float Ki_pos_re = 0.0;         //8.5;
float Kd_pos_re = 2.0;
float output_pos_re = 0.00;
float error_pos_re = 0.00;

//Revolute Velo Control
float Kp_velo_re = 2500.0;
float Ki_velo_re = 15.0;         //8.5;
float Kd_velo_re = 0.0;
float output_velo_re = 0.00;
float error_velo_re = 0.00;

//Revolute Low Pass
float revolute_radps_lowpass_prev = 0.0f;  // สถานะเก่าของความเร็วหลังกรอง
float revolute_radps_lowpass = 0.0f;  // ค่าความเร็วหลังกรองปัจจุบัน
float revolute_acceleration = 0.0f;  // เราจะคำนวณอัตราเร่ง (ดิบ)
float revolute_acceleration_lowpass_prev = 0.0f; // สถานะเก่าของอัตราเร่งหลังกรอง
float revolute_acceleration_lowpass = 0.0f;  // อัตราเร่งหลังกรอง

//Base system
uint64_t heartbeat_counter = 0;
float prev_prismatic_vel = 0.0;
float prev_prismatic_kalman_radps = 0.0;
float prev_revolute_vel = 0.0;

// Validation
uint32_t tim2_counter = 0;
uint8_t burst_mode = 0;
uint8_t flag = 0;

//JOY
uint16_t JOY_RawRead[20];
int16_t Joy_x;
int16_t Joy_y;
uint8_t Joy_run;
uint8_t Joy_save;
int count = 0.0;
int count_run = 1.0;

//Proximity
uint16_t Prox_RawRead[10];
uint8_t revolute_homed = 0;

// State
uint8_t state = 0;
uint8_t button_reset = 0;
uint8_t button_reset_prev = 0;
uint8_t button_run = 0;
uint8_t waiting_state = 0;
uint8_t button_emer = 0;

//remap
float remap_pos = 0.0;
float remap_deg = 0.0;
float theta = 0.0;

uint32_t stopCounter = 0;
uint8_t pointMoveNeedsInit = 0;
uint8_t running_flang = 0;
uint8_t pain_flang = 0;
uint8_t pointRunNeedsInit = 0;
uint8_t pen_flag = 0;

const float path[][2] = {
    {-30.77, -16.15},
    {-21.30, -18.24},
    {-13.00, -23.27},
    {-13.00, -23.27},
    {-9.04, -27.76},
    {-6.14, -33.01},
    {-6.14, -33.01},
    {-4.15, -39.19},
    {-3.30, -45.62},
    {-3.30, -45.62},
    {-3.44, -52.24},
    {-4.65, -58.75},
    {-4.65, -58.75},
    {-6.79, -64.41},
    {-10.00, -69.53},
    {-10.00, -69.53},
    {-17.39, -75.95},
    {-26.55, -79.41},
    {-26.55, -79.41},
    {-34.96, -79.93},
    {-43.23, -78.32},
    {-43.23, -78.32},
    {-53.75, -71.59},
    {-60.23, -60.92},
    {-60.23, -60.92},
    {-62.23, -50.19},
    {-61.41, -39.30},
    {-61.41, -39.30},
    {-59.19, -32.72},
    {-55.63, -26.77},
    {-55.63, -26.77},
    {-47.35, -19.72},
    {-37.01, -16.35},
    {-37.01, -16.35},
    {-33.90, -16.11},
    {-30.77, -16.15},
    {86.42, -16.13},
    {95.64, -17.74},
    {104.19, -21.53},
    {104.19, -21.53},
    {107.33, -23.52},
    {110.31, -25.73},
    {110.31, -25.73},
    {110.31, -37.19},
    {110.31, -48.65},
    {110.31, -48.65},
    {97.23, -48.63},
    {84.15, -48.61},
    {84.15, -48.61},
    {84.15, -44.98},
    {84.15, -41.36},
    {84.15, -41.36},
    {93.23, -41.36},
    {102.31, -41.36},
    {102.31, -41.36},
    {102.31, -35.61},
    {102.31, -29.86},
    {102.31, -29.86},
    {99.23, -27.70},
    {95.87, -26.02},
    {95.87, -26.02},
    {85.78, -23.50},
    {75.50, -24.98},
    {75.50, -24.98},
    {71.47, -26.85},
    {67.95, -29.57},
    {67.95, -29.57},
    {64.72, -33.92},
    {62.73, -38.96},
    {62.73, -38.96},
    {61.61, -47.58},
    {62.54, -56.22},
    {62.54, -56.22},
    {63.77, -60.16},
    {65.65, -63.84},
    {65.65, -63.84},
    {67.28, -66.09},
    {69.22, -68.08},
    {69.22, -68.08},
    {74.35, -71.20},
    {80.16, -72.71},
    {80.16, -72.71},
    {84.93, -72.94},
    {89.67, -72.32},
    {89.67, -72.32},
    {93.80, -70.81},
    {97.41, -68.29},
    {97.41, -68.29},
    {99.42, -65.75},
    {100.87, -62.85},
    {100.87, -62.85},
    {101.48, -61.24},
    {102.01, -59.60},
    {102.01, -59.60},
    {105.70, -60.61},
    {109.38, -61.62},
    {109.38, -61.62},
    {107.82, -66.35},
    {105.45, -70.72},
    {105.45, -70.72},
    {101.94, -74.51},
    {97.54, -77.21},
    {97.54, -77.21},
    {90.97, -79.31},
    {84.11, -79.94},
    {84.11, -79.94},
    {77.70, -79.45},
    {71.48, -77.81},
    {71.48, -77.81},
    {66.98, -75.69},
    {62.97, -72.74},
    {62.97, -72.74},
    {59.57, -68.94},
    {56.96, -64.55},
    {56.96, -64.55},
    {53.89, -55.25},
    {53.25, -45.47},
    {53.25, -45.47},
    {54.36, -38.16},
    {56.98, -31.25},
    {56.98, -31.25},
    {61.71, -24.73},
    {68.21, -19.99},
    {68.21, -19.99},
    {75.14, -17.30},
    {82.49, -16.15},
    {82.49, -16.15},
    {84.46, -16.09},
    {86.42, -16.13},
    {141.07, -16.15},
    {145.46, -16.95},
    {149.49, -18.88},
    {149.49, -18.88},
    {152.80, -21.83},
    {155.33, -25.47},
    {155.33, -25.47},
    {157.43, -30.42},
    {158.67, -35.65},
    {158.67, -35.65},
    {159.56, -47.45},
    {158.76, -59.25},
    {158.76, -59.25},
    {157.15, -65.53},
    {154.32, -71.37},
    {154.32, -71.37},
    {148.45, -76.96},
    {140.64, -79.11},
    {140.64, -79.11},
    {136.18, -78.92},
    {131.88, -77.73},
    {131.88, -77.73},
    {128.19, -75.49},
    {125.20, -72.38},
    {125.20, -72.38},
    {122.68, -68.13},
    {121.00, -63.49},
    {121.00, -63.49},
    {119.94, -58.19},
    {119.42, -52.80},
    {119.42, -52.80},
    {119.33, -44.34},
    {120.14, -35.91},
    {120.14, -35.91},
    {121.32, -30.69},
    {123.31, -25.72},
    {123.31, -25.72},
    {126.36, -21.36},
    {130.58, -18.12},
    {130.58, -18.12},
    {134.87, -16.56},
    {139.41, -16.09},
    {139.41, -16.09},
    {140.24, -16.12},
    {141.07, -16.15},
    {188.03, -16.07},
    {194.51, -17.22},
    {200.31, -20.35},
    {200.31, -20.35},
    {204.84, -25.28},
    {207.36, -31.49},
    {207.36, -31.49},
    {207.68, -36.84},
    {206.54, -42.08},
    {206.54, -42.08},
    {202.97, -47.20},
    {197.52, -50.23},
    {197.52, -50.23},
    {196.85, -50.41},
    {196.18, -50.59},
    {196.18, -50.59},
    {196.69, -50.84},
    {197.20, -51.09},
    {197.20, -51.09},
    {201.53, -54.46},
    {204.16, -59.27},
    {204.16, -59.27},
    {203.47, -69.06},
    {196.96, -76.41},
    {196.96, -76.41},
    {191.10, -78.68},
    {184.83, -79.08},
    {184.83, -79.08},
    {180.02, -78.14},
    {175.64, -75.93},
    {175.64, -75.93},
    {172.08, -72.58},
    {169.59, -68.37},
    {169.59, -68.37},
    {168.67, -65.80},
    {168.05, -63.14},
    {168.05, -63.14},
    {171.84, -62.46},
    {175.63, -61.79},
    {175.63, -61.79},
    {175.75, -62.46},
    {175.87, -63.14},
    {175.87, -63.14},
    {176.70, -65.96},
    {178.08, -68.57},
    {178.08, -68.57},
    {181.40, -71.59},
    {185.71, -72.87},
    {185.71, -72.87},
    {188.79, -72.76},
    {191.73, -71.84},
    {191.73, -71.84},
    {195.57, -68.31},
    {196.90, -63.26},
    {196.90, -63.26},
    {196.68, -60.92},
    {195.93, -58.68},
    {195.93, -58.68},
    {194.29, -56.47},
    {192.04, -54.88},
    {192.04, -54.88},
    {187.70, -53.28},
    {183.08, -53.03},
    {183.08, -53.03},
    {182.66, -49.70},
    {182.24, -46.37},
    {182.24, -46.37},
    {182.63, -46.47},
    {183.03, -46.57},
    {183.03, -46.57},
    {187.14, -47.19},
    {191.28, -46.74},
    {191.28, -46.74},
    {197.08, -42.94},
    {199.63, -36.49},
    {199.63, -36.49},
    {199.47, -32.67},
    {198.24, -29.06},
    {198.24, -29.06},
    {194.62, -24.82},
    {189.53, -22.56},
    {189.53, -22.56},
    {186.13, -22.34},
    {182.80, -23.03},
    {182.80, -23.03},
    {179.59, -24.93},
    {177.22, -27.81},
    {177.22, -27.81},
    {175.78, -31.04},
    {174.87, -34.45},
    {174.87, -34.45},
    {171.08, -33.95},
    {167.29, -33.44},
    {167.29, -33.44},
    {170.47, -24.27},
    {177.83, -17.94},
    {177.83, -17.94},
    {182.82, -16.39},
    {188.03, -16.07},
    {-185.39, -45.20},
    {-170.90, -45.20},
    {-156.41, -45.20},
    {-156.41, -45.20},
    {-156.41, -48.84},
    {-156.41, -52.48},
    {-156.41, -52.48},
    {-170.90, -52.48},
    {-185.39, -52.48},
    {-185.39, -52.48},
    {-185.39, -62.04},
    {-185.39, -71.60},
    {-185.39, -71.60},
    {-168.65, -71.60},
    {-151.91, -71.60},
    {-151.91, -71.60},
    {-151.91, -75.25},
    {-151.91, -78.89},
    {-151.91, -78.89},
    {-172.73, -78.89},
    {-193.56, -78.89},
    {-193.56, -78.89},
    {-193.56, -48.02},
    {-193.56, -17.14},
    {-193.56, -17.14},
    {-189.48, -17.14},
    {-185.39, -17.14},
    {-185.39, -17.14},
    {-185.39, -31.17},
    {-185.39, -45.20},
    {-131.74, -78.89},
    {-135.82, -78.89},
    {-139.91, -78.89},
    {-139.91, -78.89},
    {-139.91, -48.02},
    {-139.91, -17.14},
    {-139.91, -17.14},
    {-135.82, -17.14},
    {-131.74, -17.14},
    {-131.74, -17.14},
    {-131.74, -48.02},
    {-131.74, -78.89},
    {-92.68, -17.16},
    {-87.39, -17.55},
    {-82.22, -18.75},
    {-82.22, -18.75},
    {-78.20, -20.67},
    {-74.92, -23.68},
    {-74.92, -23.68},
    {-71.37, -31.50},
    {-71.80, -40.08},
    {-71.80, -40.08},
    {-74.94, -45.45},
    {-80.03, -49.03},
    {-80.03, -49.03},
    {-81.33, -49.56},
    {-82.67, -50.00},
    {-82.67, -50.00},
    {-82.14, -50.28},
    {-81.62, -50.55},
    {-81.62, -50.55},
    {-76.36, -55.37},
    {-74.07, -62.11},
    {-74.07, -62.11},
    {-76.96, -72.01},
    {-85.47, -77.84},
    {-85.47, -77.84},
    {-89.95, -78.67},
    {-94.50, -78.89},
    {-94.50, -78.89},
    {-106.09, -78.89},
    {-117.67, -78.89},
    {-117.67, -78.89},
    {-117.67, -48.02},
    {-117.67, -17.14},
    {-117.67, -17.14},
    {-105.90, -17.14},
    {-94.12, -17.14},
    {-94.12, -17.14},
    {-93.40, -17.15},
    {-92.68, -17.16},
    {-33.93, -23.11},
    {-44.43, -26.53},
    {-51.52, -34.99},
    {-51.52, -34.99},
    {-53.21, -40.24},
    {-53.84, -45.71},
    {-53.84, -45.71},
    {-53.67, -51.78},
    {-52.67, -57.76},
    {-52.67, -57.76},
    {-51.27, -61.76},
    {-49.08, -65.38},
    {-49.08, -65.38},
    {-41.05, -71.33},
    {-31.17, -72.90},
    {-31.17, -72.90},
    {-21.02, -69.43},
    {-14.21, -61.14},
    {-14.21, -61.14},
    {-12.42, -55.60},
    {-11.70, -49.83},
    {-11.70, -49.83},
    {-11.88, -43.56},
    {-13.15, -37.41},
    {-13.15, -37.41},
    {-17.73, -29.45},
    {-25.36, -24.32},
    {-25.36, -24.32},
    {-29.58, -23.29},
    {-33.93, -23.11},
    {138.13, -22.40},
    {137.52, -22.52},
    {136.90, -22.64},
    {136.90, -22.64},
    {133.95, -23.99},
    {131.55, -26.18},
    {131.55, -26.18},
    {129.85, -28.68},
    {128.75, -31.50},
    {128.75, -31.50},
    {127.66, -36.83},
    {127.20, -42.25},
    {127.20, -42.25},
    {127.11, -50.68},
    {127.82, -59.07},
    {127.82, -59.07},
    {128.64, -63.06},
    {130.07, -66.88},
    {130.07, -66.88},
    {131.97, -69.68},
    {134.63, -71.76},
    {134.63, -71.76},
    {139.43, -72.87},
    {144.20, -71.61},
    {144.20, -71.61},
    {147.91, -68.25},
    {150.07, -63.72},
    {150.07, -63.72},
    {151.16, -58.38},
    {151.63, -52.95},
    {151.63, -52.95},
    {151.72, -44.60},
    {151.07, -36.26},
    {151.07, -36.26},
    {150.34, -32.45},
    {149.03, -28.80},
    {149.03, -28.80},
    {146.99, -25.86},
    {144.22, -23.59},
    {144.22, -23.59},
    {141.27, -22.50},
    {138.13, -22.40},
    {-109.50, -52.95},
    {-109.50, -62.27},
    {-109.50, -71.60},
    {-109.50, -71.60},
    {-102.53, -71.63},
    {-95.55, -71.59},
    {-95.55, -71.59},
    {-92.02, -71.44},
    {-88.51, -70.94},
    {-88.51, -70.94},
    {-84.62, -68.86},
    {-82.45, -65.02},
    {-82.45, -65.02},
    {-82.09, -61.40},
    {-82.97, -57.88},
    {-82.97, -57.88},
    {-84.89, -55.44},
    {-87.60, -53.91},
    {-87.60, -53.91},
    {-90.02, -53.29},
    {-92.50, -53.05},
    {-92.50, -53.05},
    {-94.32, -52.97},
    {-96.15, -52.95},
    {-96.15, -52.95},
    {-102.82, -52.95},
    {-109.50, -52.95},
    {-109.50, -24.43},
    {-109.50, -35.04},
    {-109.50, -45.66},
    {-109.50, -45.66},
    {-102.36, -45.66},
    {-95.22, -45.66},
    {-95.22, -45.66},
    {-91.09, -45.52},
    {-87.01, -44.87},
    {-87.01, -44.87},
    {-81.75, -41.65},
    {-79.54, -35.89},
    {-79.54, -35.89},
    {-80.00, -31.61},
    {-82.12, -27.86},
    {-82.12, -27.86},
    {-83.89, -26.38},
    {-85.97, -25.40},
    {-85.97, -25.40},
    {-89.09, -24.66},
    {-92.29, -24.45},
    {-92.29, -24.45},
    {-93.21, -24.43},
    {-94.12, -24.43},
    {-94.12, -24.43},
    {-101.81, -24.43},
    {-109.50, -24.43},
    {49.58, -5.48},
    {24.45, -5.48},
    {-0.67, -5.48},
    {-0.67, -5.48},
    {-0.67, -2.74},
    {-0.67, 0.00},
    {-0.67, 0.00},
    {24.45, 0.00},
    {49.58, 0.00},
    {49.58, 0.00},
    {49.58, -2.74},
    {49.58, -5.48},
    {-1, -1}
};

static uint16_t path_idx = 0;
static uint8_t painInit = 1;
uint8_t count_pain = 0;
float goal_r_mm = 0.0;
float goal_th_deg = 0.0;
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_TIM1_Init(void);
static void MX_TIM2_Init(void);
static void MX_TIM4_Init(void);
static void MX_TIM5_Init(void);
static void MX_TIM3_Init(void);
static void MX_ADC1_Init(void);
static void MX_TIM16_Init(void);
static void MX_USART2_UART_Init(void);
static void MX_ADC2_Init(void);
static void MX_TIM8_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
 * @brief  The application entry point.
 * @retval int
 */
int main(void) {

	/* USER CODE BEGIN 1 */

	/* USER CODE END 1 */

	/* MCU Configuration--------------------------------------------------------*/

	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();

	/* USER CODE BEGIN Init */

	/* USER CODE END Init */

	/* Configure the system clock */
	SystemClock_Config();

	/* USER CODE BEGIN SysInit */

	/* USER CODE END SysInit */

	/* Initialize all configured peripherals */
	MX_GPIO_Init();
	MX_DMA_Init();
	MX_TIM1_Init();
	MX_TIM2_Init();
	MX_TIM4_Init();
	MX_TIM5_Init();
	MX_TIM3_Init();
	MX_ADC1_Init();
	MX_TIM16_Init();
	MX_USART2_UART_Init();
	MX_ADC2_Init();
	MX_TIM8_Init();
	/* USER CODE BEGIN 2 */
	hmodbus.huart = &huart2;
	hmodbus.htim = &htim16;
	hmodbus.slaveAddress = 0x15;
	hmodbus.RegisterSize = 70;
	Modbus_init(&hmodbus, &registerFrame);

	PID_POS_pris.Kp = Kp_pos_pris;
	PID_POS_pris.Ki = Ki_pos_pris;
	PID_POS_pris.Kd = Kd_pos_pris;
	arm_pid_init_f32(&PID_POS_pris, 0);

	PID_POS_re.Kp = Kp_pos_re;
	PID_POS_re.Ki = Ki_pos_re;
	PID_POS_re.Kd = Kd_pos_re;
	arm_pid_init_f32(&PID_POS_re, 0);

	MotorInit(&prismatic_motor, &htim1, TIM_CHANNEL_3, GPIOC, GPIO_PIN_7);
	MotorInit(&revolute_motor, &htim1, TIM_CHANNEL_2, GPIOC, GPIO_PIN_6);
	HAL_TIM_Base_Start(&htim8);
	HAL_TIM_PWM_Start(&htim8, TIM_CHANNEL_1);

	QEIInit(&prismatic_encoder, &htim4, 8192, 1000, 65536);
	QEIInit(&revolute_encoder, &htim3, 8192, 1000, 65536);

	PIDInit(&prismatic_vel_control, 65535, -65535);
	PIDInit(&revolute_vel_control, 65535, -65535);

	HAL_TIM_Base_Start_IT(&htim5);
	HAL_TIM_Base_Start_IT(&htim2);

	HAL_ADC_Start_DMA(&hadc1, JOY_RawRead, 20);
	HAL_ADC_Start_DMA(&hadc2, Prox_RawRead, 10);

//	MotorInit(&revolute_motor, &htim1, TIM_CHANNEL_1, GPIOB, GPIO_PIN_0);

//	registerFrame[4].U16 = 1;
//	registerFrame[5].U16 = 0;
	/* USER CODE END 2 */

	/* Infinite loop */
	/* USER CODE BEGIN WHILE */
	while (1) {
		/* USER CODE END WHILE */

		/* USER CODE BEGIN 3 */
		Modbus_Protocal_Worker();
	}
	/* USER CODE END 3 */
}

/**
 * @brief System Clock Configuration
 * @retval None
 */
void SystemClock_Config(void) {
	RCC_OscInitTypeDef RCC_OscInitStruct = { 0 };
	RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 };

	/** Configure the main internal regulator output voltage
	 */
	HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST);

	/** Initializes the RCC Oscillators according to the specified parameters
	 * in the RCC_OscInitTypeDef structure.
	 */
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
	RCC_OscInitStruct.HSIState = RCC_HSI_ON;
	RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
	RCC_OscInitStruct.PLL.PLLM = RCC_PLLM_DIV4;
	RCC_OscInitStruct.PLL.PLLN = 85;
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
	RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
	RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
		Error_Handler();
	}

	/** Initializes the CPU, AHB and APB buses clocks
	 */
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK
			| RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK) {
		Error_Handler();
	}
}

/**
 * @brief ADC1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_ADC1_Init(void) {

	/* USER CODE BEGIN ADC1_Init 0 */

	/* USER CODE END ADC1_Init 0 */

	ADC_MultiModeTypeDef multimode = { 0 };
	ADC_ChannelConfTypeDef sConfig = { 0 };

	/* USER CODE BEGIN ADC1_Init 1 */

	/* USER CODE END ADC1_Init 1 */

	/** Common config
	 */
	hadc1.Instance = ADC1;
	hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
	hadc1.Init.Resolution = ADC_RESOLUTION_12B;
	hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
	hadc1.Init.GainCompensation = 0;
	hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
	hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
	hadc1.Init.LowPowerAutoWait = DISABLE;
	hadc1.Init.ContinuousConvMode = ENABLE;
	hadc1.Init.NbrOfConversion = 2;
	hadc1.Init.DiscontinuousConvMode = DISABLE;
	hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
	hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
	hadc1.Init.DMAContinuousRequests = ENABLE;
	hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
	hadc1.Init.OversamplingMode = DISABLE;
	if (HAL_ADC_Init(&hadc1) != HAL_OK) {
		Error_Handler();
	}

	/** Configure the ADC multi-mode
	 */
	multimode.Mode = ADC_MODE_INDEPENDENT;
	if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK) {
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_7;
	sConfig.Rank = ADC_REGULAR_RANK_1;
	sConfig.SamplingTime = ADC_SAMPLETIME_640CYCLES_5;
	sConfig.SingleDiff = ADC_SINGLE_ENDED;
	sConfig.OffsetNumber = ADC_OFFSET_NONE;
	sConfig.Offset = 0;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK) {
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_8;
	sConfig.Rank = ADC_REGULAR_RANK_2;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN ADC1_Init 2 */

	/* USER CODE END ADC1_Init 2 */

}

/**
 * @brief ADC2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_ADC2_Init(void) {

	/* USER CODE BEGIN ADC2_Init 0 */

	/* USER CODE END ADC2_Init 0 */

	ADC_ChannelConfTypeDef sConfig = { 0 };

	/* USER CODE BEGIN ADC2_Init 1 */

	/* USER CODE END ADC2_Init 1 */

	/** Common config
	 */
	hadc2.Instance = ADC2;
	hadc2.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
	hadc2.Init.Resolution = ADC_RESOLUTION_12B;
	hadc2.Init.DataAlign = ADC_DATAALIGN_RIGHT;
	hadc2.Init.GainCompensation = 0;
	hadc2.Init.ScanConvMode = ADC_SCAN_DISABLE;
	hadc2.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
	hadc2.Init.LowPowerAutoWait = DISABLE;
	hadc2.Init.ContinuousConvMode = ENABLE;
	hadc2.Init.NbrOfConversion = 1;
	hadc2.Init.DiscontinuousConvMode = DISABLE;
	hadc2.Init.ExternalTrigConv = ADC_SOFTWARE_START;
	hadc2.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
	hadc2.Init.DMAContinuousRequests = ENABLE;
	hadc2.Init.Overrun = ADC_OVR_DATA_PRESERVED;
	hadc2.Init.OversamplingMode = DISABLE;
	if (HAL_ADC_Init(&hadc2) != HAL_OK) {
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_6;
	sConfig.Rank = ADC_REGULAR_RANK_1;
	sConfig.SamplingTime = ADC_SAMPLETIME_640CYCLES_5;
	sConfig.SingleDiff = ADC_SINGLE_ENDED;
	sConfig.OffsetNumber = ADC_OFFSET_NONE;
	sConfig.Offset = 0;
	if (HAL_ADC_ConfigChannel(&hadc2, &sConfig) != HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN ADC2_Init 2 */

	/* USER CODE END ADC2_Init 2 */

}

/**
 * @brief TIM1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM1_Init(void) {

	/* USER CODE BEGIN TIM1_Init 0 */

	/* USER CODE END TIM1_Init 0 */

	TIM_ClockConfigTypeDef sClockSourceConfig = { 0 };
	TIM_MasterConfigTypeDef sMasterConfig = { 0 };
	TIM_OC_InitTypeDef sConfigOC = { 0 };
	TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = { 0 };

	/* USER CODE BEGIN TIM1_Init 1 */

	/* USER CODE END TIM1_Init 1 */
	htim1.Instance = TIM1;
	htim1.Init.Prescaler = 169;
	htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim1.Init.Period = 19999;
	htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim1.Init.RepetitionCounter = 0;
	htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim1) != HAL_OK) {
		Error_Handler();
	}
	sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
	if (HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig) != HAL_OK) {
		Error_Handler();
	}
	if (HAL_TIM_PWM_Init(&htim1) != HAL_OK) {
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig)
			!= HAL_OK) {
		Error_Handler();
	}
	sConfigOC.OCMode = TIM_OCMODE_PWM1;
	sConfigOC.Pulse = 0;
	sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
	sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
	sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
	sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
	sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
	if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_2)
			!= HAL_OK) {
		Error_Handler();
	}
	if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_3)
			!= HAL_OK) {
		Error_Handler();
	}
	sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
	sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
	sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
	sBreakDeadTimeConfig.DeadTime = 0;
	sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
	sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
	sBreakDeadTimeConfig.BreakFilter = 0;
	sBreakDeadTimeConfig.BreakAFMode = TIM_BREAK_AFMODE_INPUT;
	sBreakDeadTimeConfig.Break2State = TIM_BREAK2_DISABLE;
	sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
	sBreakDeadTimeConfig.Break2Filter = 0;
	sBreakDeadTimeConfig.Break2AFMode = TIM_BREAK_AFMODE_INPUT;
	sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
	if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig)
			!= HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN TIM1_Init 2 */

	/* USER CODE END TIM1_Init 2 */
	HAL_TIM_MspPostInit(&htim1);

}

/**
 * @brief TIM2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM2_Init(void) {

	/* USER CODE BEGIN TIM2_Init 0 */

	/* USER CODE END TIM2_Init 0 */

	TIM_ClockConfigTypeDef sClockSourceConfig = { 0 };
	TIM_MasterConfigTypeDef sMasterConfig = { 0 };

	/* USER CODE BEGIN TIM2_Init 1 */

	/* USER CODE END TIM2_Init 1 */
	htim2.Instance = TIM2;
	htim2.Init.Prescaler = 169;
	htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim2.Init.Period = 999;
	htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim2) != HAL_OK) {
		Error_Handler();
	}
	sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
	if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK) {
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig)
			!= HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN TIM2_Init 2 */

	/* USER CODE END TIM2_Init 2 */

}

/**
 * @brief TIM3 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM3_Init(void) {

	/* USER CODE BEGIN TIM3_Init 0 */

	/* USER CODE END TIM3_Init 0 */

	TIM_Encoder_InitTypeDef sConfig = { 0 };
	TIM_MasterConfigTypeDef sMasterConfig = { 0 };

	/* USER CODE BEGIN TIM3_Init 1 */

	/* USER CODE END TIM3_Init 1 */
	htim3.Instance = TIM3;
	htim3.Init.Prescaler = 0;
	htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim3.Init.Period = 65535;
	htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	sConfig.EncoderMode = TIM_ENCODERMODE_TI12;
	sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;
	sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
	sConfig.IC1Prescaler = TIM_ICPSC_DIV1;
	sConfig.IC1Filter = 0;
	sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;
	sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
	sConfig.IC2Prescaler = TIM_ICPSC_DIV1;
	sConfig.IC2Filter = 0;
	if (HAL_TIM_Encoder_Init(&htim3, &sConfig) != HAL_OK) {
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig)
			!= HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN TIM3_Init 2 */

	/* USER CODE END TIM3_Init 2 */

}

/**
 * @brief TIM4 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM4_Init(void) {

	/* USER CODE BEGIN TIM4_Init 0 */

	/* USER CODE END TIM4_Init 0 */

	TIM_Encoder_InitTypeDef sConfig = { 0 };
	TIM_MasterConfigTypeDef sMasterConfig = { 0 };

	/* USER CODE BEGIN TIM4_Init 1 */

	/* USER CODE END TIM4_Init 1 */
	htim4.Instance = TIM4;
	htim4.Init.Prescaler = 0;
	htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim4.Init.Period = 65535;
	htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	sConfig.EncoderMode = TIM_ENCODERMODE_TI12;
	sConfig.IC1Polarity = TIM_ICPOLARITY_RISING;
	sConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
	sConfig.IC1Prescaler = TIM_ICPSC_DIV1;
	sConfig.IC1Filter = 0;
	sConfig.IC2Polarity = TIM_ICPOLARITY_RISING;
	sConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
	sConfig.IC2Prescaler = TIM_ICPSC_DIV1;
	sConfig.IC2Filter = 0;
	if (HAL_TIM_Encoder_Init(&htim4, &sConfig) != HAL_OK) {
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig)
			!= HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN TIM4_Init 2 */

	/* USER CODE END TIM4_Init 2 */

}

/**
 * @brief TIM5 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM5_Init(void) {

	/* USER CODE BEGIN TIM5_Init 0 */

	/* USER CODE END TIM5_Init 0 */

	TIM_ClockConfigTypeDef sClockSourceConfig = { 0 };
	TIM_MasterConfigTypeDef sMasterConfig = { 0 };

	/* USER CODE BEGIN TIM5_Init 1 */

	/* USER CODE END TIM5_Init 1 */
	htim5.Instance = TIM5;
	htim5.Init.Prescaler = 169;
	htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim5.Init.Period = 999;
	htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim5.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim5) != HAL_OK) {
		Error_Handler();
	}
	sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
	if (HAL_TIM_ConfigClockSource(&htim5, &sClockSourceConfig) != HAL_OK) {
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig)
			!= HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN TIM5_Init 2 */

	/* USER CODE END TIM5_Init 2 */

}

/**
 * @brief TIM8 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM8_Init(void) {

	/* USER CODE BEGIN TIM8_Init 0 */

	/* USER CODE END TIM8_Init 0 */

	TIM_ClockConfigTypeDef sClockSourceConfig = { 0 };
	TIM_MasterConfigTypeDef sMasterConfig = { 0 };
	TIM_OC_InitTypeDef sConfigOC = { 0 };
	TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = { 0 };

	/* USER CODE BEGIN TIM8_Init 1 */

	/* USER CODE END TIM8_Init 1 */
	htim8.Instance = TIM8;
	htim8.Init.Prescaler = 169;
	htim8.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim8.Init.Period = 19999;
	htim8.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim8.Init.RepetitionCounter = 0;
	htim8.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim8) != HAL_OK) {
		Error_Handler();
	}
	sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
	if (HAL_TIM_ConfigClockSource(&htim8, &sClockSourceConfig) != HAL_OK) {
		Error_Handler();
	}
	if (HAL_TIM_PWM_Init(&htim8) != HAL_OK) {
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim8, &sMasterConfig)
			!= HAL_OK) {
		Error_Handler();
	}
	sConfigOC.OCMode = TIM_OCMODE_PWM1;
	sConfigOC.Pulse = 0;
	sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
	sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
	sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
	sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
	sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
	if (HAL_TIM_PWM_ConfigChannel(&htim8, &sConfigOC, TIM_CHANNEL_1)
			!= HAL_OK) {
		Error_Handler();
	}
	sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
	sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
	sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
	sBreakDeadTimeConfig.DeadTime = 0;
	sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
	sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
	sBreakDeadTimeConfig.BreakFilter = 0;
	sBreakDeadTimeConfig.BreakAFMode = TIM_BREAK_AFMODE_INPUT;
	sBreakDeadTimeConfig.Break2State = TIM_BREAK2_DISABLE;
	sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
	sBreakDeadTimeConfig.Break2Filter = 0;
	sBreakDeadTimeConfig.Break2AFMode = TIM_BREAK_AFMODE_INPUT;
	sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
	if (HAL_TIMEx_ConfigBreakDeadTime(&htim8, &sBreakDeadTimeConfig)
			!= HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN TIM8_Init 2 */

	/* USER CODE END TIM8_Init 2 */
	HAL_TIM_MspPostInit(&htim8);

}

/**
 * @brief TIM16 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM16_Init(void) {

	/* USER CODE BEGIN TIM16_Init 0 */

	/* USER CODE END TIM16_Init 0 */

	/* USER CODE BEGIN TIM16_Init 1 */

	/* USER CODE END TIM16_Init 1 */
	htim16.Instance = TIM16;
	htim16.Init.Prescaler = 169;
	htim16.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim16.Init.Period = 1145;
	htim16.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim16.Init.RepetitionCounter = 0;
	htim16.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim16) != HAL_OK) {
		Error_Handler();
	}
	if (HAL_TIM_OnePulse_Init(&htim16, TIM_OPMODE_SINGLE) != HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN TIM16_Init 2 */

	/* USER CODE END TIM16_Init 2 */

}

/**
 * @brief USART2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_USART2_UART_Init(void) {

	/* USER CODE BEGIN USART2_Init 0 */

	/* USER CODE END USART2_Init 0 */

	/* USER CODE BEGIN USART2_Init 1 */

	/* USER CODE END USART2_Init 1 */
	huart2.Instance = USART2;
	huart2.Init.BaudRate = 115200;
	huart2.Init.WordLength = UART_WORDLENGTH_9B;
	huart2.Init.StopBits = UART_STOPBITS_1;
	huart2.Init.Parity = UART_PARITY_EVEN;
	huart2.Init.Mode = UART_MODE_TX_RX;
	huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
	huart2.Init.OverSampling = UART_OVERSAMPLING_16;
	huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
	huart2.Init.ClockPrescaler = UART_PRESCALER_DIV1;
	huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
	if (HAL_UART_Init(&huart2) != HAL_OK) {
		Error_Handler();
	}
	if (HAL_UARTEx_SetTxFifoThreshold(&huart2, UART_TXFIFO_THRESHOLD_1_8)
			!= HAL_OK) {
		Error_Handler();
	}
	if (HAL_UARTEx_SetRxFifoThreshold(&huart2, UART_RXFIFO_THRESHOLD_1_8)
			!= HAL_OK) {
		Error_Handler();
	}
	if (HAL_UARTEx_DisableFifoMode(&huart2) != HAL_OK) {
		Error_Handler();
	}
	/* USER CODE BEGIN USART2_Init 2 */

	/* USER CODE END USART2_Init 2 */

}

/**
 * Enable DMA controller clock
 */
static void MX_DMA_Init(void) {

	/* DMA controller clock enable */
	__HAL_RCC_DMAMUX1_CLK_ENABLE();
	__HAL_RCC_DMA1_CLK_ENABLE();

	/* DMA interrupt init */
	/* DMA1_Channel1_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
	/* DMA1_Channel2_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel2_IRQn);
	/* DMA1_Channel3_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel3_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel3_IRQn);
	/* DMA1_Channel4_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel4_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel4_IRQn);

}

/**
 * @brief GPIO Initialization Function
 * @param None
 * @retval None
 */
static void MX_GPIO_Init(void) {
	GPIO_InitTypeDef GPIO_InitStruct = { 0 };
	/* USER CODE BEGIN MX_GPIO_Init_1 */

	/* USER CODE END MX_GPIO_Init_1 */

	/* GPIO Ports Clock Enable */
	__HAL_RCC_GPIOC_CLK_ENABLE();
	__HAL_RCC_GPIOF_CLK_ENABLE();
	__HAL_RCC_GPIOA_CLK_ENABLE();
	__HAL_RCC_GPIOB_CLK_ENABLE();

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_6 | GPIO_PIN_7 | GPIO_PIN_10,
			GPIO_PIN_RESET);

	/*Configure GPIO pin : PC13 */
	GPIO_InitStruct.Pin = GPIO_PIN_13;
	GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

	/*Configure GPIO pins : PC3 PC9 */
	GPIO_InitStruct.Pin = GPIO_PIN_3 | GPIO_PIN_9;
	GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

	/*Configure GPIO pins : RUN_Joy_Pin Save_Joy_Pin */
	GPIO_InitStruct.Pin = RUN_Joy_Pin | Save_Joy_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_PULLUP;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

	/*Configure GPIO pin : PA4 */
	GPIO_InitStruct.Pin = GPIO_PIN_4;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

	/*Configure GPIO pin : LD2_Pin */
	GPIO_InitStruct.Pin = LD2_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);

	/*Configure GPIO pins : PB11 PB12 */
	GPIO_InitStruct.Pin = GPIO_PIN_11 | GPIO_PIN_12;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

	/*Configure GPIO pins : PB13 PB14 */
	GPIO_InitStruct.Pin = GPIO_PIN_13 | GPIO_PIN_14;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

	/*Configure GPIO pins : PC6 PC7 PC10 */
	GPIO_InitStruct.Pin = GPIO_PIN_6 | GPIO_PIN_7 | GPIO_PIN_10;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

	/*Configure GPIO pin : PC12 */
	GPIO_InitStruct.Pin = GPIO_PIN_12;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

	/* EXTI interrupt init*/
	HAL_NVIC_SetPriority(EXTI3_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(EXTI3_IRQn);

	HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);

	/* USER CODE BEGIN MX_GPIO_Init_2 */

	/* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */
void Prismatic_CasCadeControl() {
	registerFrame[4].U16 = 1;
	registerFrame[5].U16 = 0;
	float setpoint_pris_abs = Trapezoidal_GetCurrentAbsolute(&prisProfile);

	error_pos_pris = setpoint_pris_abs - (float) ball_screw_pos;
	output_pos_pris = arm_pid_f32(&PID_POS_pris, error_pos_pris);

	if (output_pos_pris > 550) {
		output_pos_pris = 550;
	} else if (output_pos_pris < -550) {
		output_pos_pris = -550;
	}

	error_velo_pris = output_pos_pris - ball_screw_vel;
	output_velo_pris = PIDCompute(&prismatic_vel_control, Kp_velo_pris,
			Ki_velo_pris, Kd_velo_pris, error_velo_pris);

	if (limit_r == 1 && output_prismatic < 0) {
		output_prismatic = 0;
	} else if (limit_l == 1 && output_prismatic > 0) {
		output_prismatic = 0;
	}

	// Motor control}
	if (error_pos_pris <= 0.1 && error_pos_pris >= -0.1) {
		output_prismatic = 0;
		registerFrame[4].U16 = 0;
		registerFrame[5].U16 = 1;
	} else {
		output_prismatic = output_velo_pris;
	}
}

void Revolute_CasCadeControl() {
//	error_pos_re = target_position_revolute - revolute_encoder.rads;
	registerFrame[4].U16 = 1;
	registerFrame[5].U16 = 0;
	float setpoint_rev_abs = Trapezoidal_GetCurrentAbsolute(&revProfile);
	error_pos_re = setpoint_rev_abs - revolute_encoder.rads;
	output_pos_re = arm_pid_f32(&PID_POS_re, error_pos_re);

//	error_pos_re = revProfile.current_position - revolute_encoder.rads;
//
//	output_pos_re = arm_pid_f32(&PID_POS_re, error_pos_re);

	if (output_pos_re > 300) {
		output_pos_re = 300;
	} else if (output_pos_re < -300) {
		output_pos_re = -300;
	}

	error_velo_re = output_pos_re - (revolute_encoder.radps / 2);

	output_velo_re = PIDCompute(&revolute_vel_control, Kp_velo_re, Ki_velo_re,
			Kd_velo_re, error_velo_re);

	if (revolute_flag == 1 && output_revolute > 0) {
		output_revolute = 0;
	} else if (revolute_encoder.rads >= (2 * M_PI) && output_revolute < 0) {
		output_revolute = 0;
	}
	// Motor control
	if (revolute_encoder.rads >= target_position_revolute - 0.1
			&& revolute_encoder.rads <= target_position_revolute + 0.1) {
		{
			stopCounter++;
			if (stopCounter >= 1500) {
				output_revolute = 0;
				registerFrame[4].U16 = 0;
				registerFrame[5].U16 = 1;
			}
		}
	} else {
		stopCounter = 0;
		output_revolute = output_velo_re;
	}
}

void ball_screw_converter() {
	ball_screw_pos = (prismatic_encoder.rads * (16.00f / (2.0f * M_PI)));
	ball_screw_vel = prismatic_radps_lowpass * (16.0f / (2.0f * M_PI));
}

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
	if (GPIO_Pin == GPIO_PIN_13) {
		current_state = STATE_ERROR;
		registerFrame[1].U16 = STATUS_IDLE;
	}
}

long map(long x, long in_min, long in_max, long out_min, long out_max) {
	return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

float mapf(float x, float in_min, float in_max, float out_min, float out_max) {
	return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {

	// sensor timer 1000 hz
	if (htim == &htim2) {
		HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);
//		MotorSet(&revolute_motor, 1000, 65535);
		QEIPosVelUpdate(&prismatic_encoder);
		QEIPosVelUpdate(&revolute_encoder);
		//Limit Switch check
		limit_l = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_11);
		limit_r = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_12);
		limit_plot = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_13);
		//Joy Calculate

		// filter
		int32_t sum_x = 0, sum_y = 0;
		for (int i = 0; i < 20; i++) {
			if ((i & 1) == 0)
				sum_y += JOY_RawRead[i];
			else
				sum_x += JOY_RawRead[i];
		}

		int32_t raw_x = sum_x / 10;
		int32_t raw_y = sum_y / 10;

		if (raw_x < 1700 && raw_x > 1500) {
			raw_x = 3400 / 2;
		}
		if (raw_y < 1700 && raw_y > 1500) {
			raw_y = 3400 / 2;
		}

		Joy_x = map(raw_x, RAW_MIN, RAW_MAX, OUT_MIN, OUT_MAX);
		Joy_y = map(raw_y, RAW_MIN, RAW_MAX, OUT_MIN, OUT_MAX);

		// Joy button
//		Joy_run = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0);
//		Joy_save = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_1);

		//Prismatic Low pass filter
		prismatic_radps_lowpass = prismatic_radps_lowpass_prev
				+ alpha
						* (prismatic_encoder.radps
								- prismatic_radps_lowpass_prev);

		prismatic_acceleration = ((prismatic_radps_lowpass
				- prismatic_radps_lowpass_prev) / dt);
		prismatic_radps_lowpass_prev = prismatic_radps_lowpass;
		prismatic_acceleration_lowpass = prismatic_acceleration_lowpass_prev
				+ alpha
						* (prismatic_acceleration
								- prismatic_acceleration_lowpass_prev);
		ball_screw_converter();

		// ==== Revolute Low‐Pass Filter ====
		// 1) กรองความเร็ว (rad/s) ของแกน Revolute
		revolute_radps_lowpass =
				revolute_radps_lowpass_prev
						+ alpha
								* (revolute_encoder.radps
										- revolute_radps_lowpass_prev);
		// 2) คำนวณอัตราเร่งดิบ (rad/s^2) จากความเปลี่ยนแปลงของค่าที่กรองแล้ว
		revolute_acceleration = (revolute_radps_lowpass
				- revolute_radps_lowpass_prev) / dt;
		// 3) กรองอัตราเร่งให้ลื่น (หากต้องการใช้ค่าเร่งหลังกรอง)
		revolute_acceleration_lowpass = revolute_acceleration_lowpass_prev
				+ alpha
						* (revolute_acceleration
								- revolute_acceleration_lowpass_prev);
		// 4) เก็บสถานะย้อนกลับไว้ใช้รอบถัดไป
		revolute_radps_lowpass_prev = revolute_radps_lowpass;
		revolute_acceleration_lowpass_prev = revolute_acceleration_lowpass;

		// Prox shimttrigger
//		revolute_flag = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4);
		if (Prox_RawRead[0] > 3000) {
			revolute_flag = 0;
		} else if (Prox_RawRead[0] < 1500) {
			revolute_flag = 1;
		}

		//Servo
		if (registerFrame[4].U16 == 1) {
			__HAL_TIM_SET_COMPARE(&htim8, TIM_CHANNEL_1, 1600);
		} else if (registerFrame[5].U16 == 1) {
			__HAL_TIM_SET_COMPARE(&htim8, TIM_CHANNEL_1, 2200);
		}
//		__HAL_TIM_SET_COMPARE(&htim8, TIM_CHANNEL_1, motor_voltage);
		//button
		Joy_save = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_13);
		Joy_run = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_14);
		button_emer =
				(HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13) == GPIO_PIN_SET) ? 1 : 0;

		button_reset =
				(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_13) == GPIO_PIN_SET
						&& button_emer == 1) ? 1 : 0;

		button_run =
				(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_14) == GPIO_PIN_SET
						&& button_emer) ? 1 : 0;

		MotorSet(&prismatic_motor, 1000, output_prismatic);
		MotorSet(&revolute_motor, 1000, output_revolute);

		// Protocal
		// Heart beat protocal 0.5 sec
		if (heartbeat_counter > 500) {
			heartbeat_counter = 0;
			registerFrame[0x00].U16 =
					(registerFrame[0X00].U16 == 0) ? 22881 : 0;
		}
		heartbeat_counter++;
	}
	// state timer 1000 hz
	if (htim == &htim5) {
		// ตรวจสอบคำสั่งหยุดฉุกเฉิน (มีความสำคัญสูงสุด)
		if (registerFrame[1].U16 & STATUS_STOP) {
			current_state = STATE_STOPPING;
		}
		if ((registerFrame[1].U16 & STATUS_HOME) && pain_flang == 0) {
			current_state = STATE_HOMING;
		} else if ((registerFrame[1].U16 & STATUS_JOG) && running_flang == 0) {
			current_state = STATE_JOGGING;
			registerFrame[10].U16 = STATUS_JOG;
		} else if (registerFrame[1].U16 & STATUS_POINT) {
			current_state = STATE_POINT_MOVING;
			pointMoveNeedsInit = 1;
			registerFrame[10].U16 = STATUS_POINT;
		} else if (registerFrame[1].U16 & STATUS_GO_TO_TARGET) {
			current_state = STATE_GO_TO_TARGET;
			registerFrame[10].U16 = STATUS_GO_TO_TARGET;
		} else if (registerFrame[1].U16 & STATUS_IDLE) {
			current_state = STATE_IDLE;
		}
		if (registerFrame[4].U16 == 1 && registerFrame[5].U16 == 0) {
			//Pen Up Servo On
			registerFrame[3].U16 = 1 << 0;
		} else {
			//Pen Doen Servo Off
			registerFrame[3].U16 = 1 << 1;
		}

		if (button_reset == 1
				&& (current_state == STATE_ERROR || current_state == STATE_IDLE)
				&& button_emer == 1) {
			registerFrame[1].U16 = STATUS_HOME;
		}

		switch (current_state) {
		case STATE_HOMING:

			if (pen_flag == 0) {
				pen_flag = 1;
				count_run = 0;
			}

			if (count_run <= 1500) {
				output_prismatic = 0;
				output_revolute = 0;
				registerFrame[4].U16 = 1;
				registerFrame[5].U16 = 0;

				count_run++;
			} else {
				if (limit_r != 1) {
					output_prismatic = -(65535 / 2.0);
				} else if (limit_r == 1) {
					limit_l_prev = 1;
					output_prismatic = 0;
					QEI_Reset(&prismatic_encoder);
					QEIInit(&prismatic_encoder, &htim4, 8192, 1000, 65536);
				}
				if (revolute_flag != 1) {
					output_revolute = -60000;
				} else if (revolute_flag == 1) {
					revolute_homed = 1; // Check Proximity trick
					output_revolute = 0;
					QEI_Reset(&revolute_encoder);
					QEIInit(&revolute_encoder, &htim3, 8192, 1000, 65536);
				}
				target_position_prismatic = 0;
				target_position_revolute = 0;
				error_pos_re = 0;
				error_pos_pris = 0;
				registerFrame[10].U16 = STATUS_HOME;
				if (button_run == 1) {
					current_state = STATE_PAIN;
					pain_flang = 1;
				}
			}
			break;
		case STATE_PAIN:
			// ถ้าวิ่งจนครบทุกจุด ให้ข้ามไปโฮมมิ่ง
			if (path_idx >= PATH_POINTS) {
				registerFrame[4].U16 = 1;
				registerFrame[5].U16 = 0;
				pain_flang = 0;
				current_state = STATE_HOMING;
				break;
			}

			if (painInit) {
				float x_mm = path[path_idx][0];
				float y_mm = path[path_idx][1];



				theta = atan2(y_mm, x_mm);
				if (theta < 0.0f)
					theta += 2.0f * M_PI;

				theta *= 2.0;

				if (theta <= 2.0 *M_PI) {
					target_position_revolute = theta;
					target_position_prismatic = 300 + (sqrt((x_mm * x_mm) + (y_mm * y_mm)));
				} else if (theta > 2.0 *M_PI) {
					target_position_revolute = (float) (fabs(M_PI - theta));
					target_position_prismatic = mapf(sqrt((x_mm * x_mm) + (y_mm * y_mm)),
							-300, 0, 300, 600);
				}

//				target_position_prismatic = 300.0 - (sqrt((x_mm * x_mm) + (y_mm * y_mm)));
//				target_position_revolute = target_position_revolute * (2 * M_PI / 180.0f);

				Trapezoidal_Init(&prisProfile, (float) ball_screw_pos,
						target_position_prismatic, 550.0f, 250.0f);
				Trapezoidal_Init(&revProfile, revolute_encoder.rads,
						target_position_revolute, 2.0f, 0.4f);

				painInit = 0;
			}

			if (!prisProfile.finished)
				Trapezoidal_Update(&prisProfile, dt);
			if (!revProfile.finished)
				Trapezoidal_Update(&revProfile, dt);
			Prismatic_CasCadeControl();
			Revolute_CasCadeControl();

			if ((limit_r && output_prismatic < 0)
					|| (limit_l && output_prismatic > 0))
				output_prismatic = 0;
			if ((revolute_flag && output_revolute < 0)
					|| (revolute_encoder.rads >= 2.0f * M_PI
							&& output_revolute > 0))
				output_revolute = 0;
			if (prisProfile.finished && revProfile.finished && output_prismatic == 0 && output_revolute == 0) {
				registerFrame[4].U16 = 0;
				registerFrame[5].U16 = 1;
				path_idx++;
				painInit = 1;
			}
			break;
		case STATE_JOGGING:
			//Call joystick mode
			registerFrame[4].U16 = 1;
			registerFrame[5].U16 = 0;
			joy_flag = 1;

			if (limit_r == 1) {
				output_prismatic = 0;
				QEI_Reset(&prismatic_encoder);
				QEIInit(&prismatic_encoder, &htim4, 8192, 1000, 65536);
			}

			if (revolute_flag == 1) {
				output_revolute = 0;
				QEI_Reset(&revolute_encoder);
				QEIInit(&revolute_encoder, &htim3, 8192, 1000, 65536);
			}

			output_prismatic = (Joy_x / 100.0) * 30000;

			if (limit_r == 1 && output_prismatic < 0) {
				output_prismatic = 0;
			} else if (limit_l == 1 && output_prismatic > 0) {
				output_prismatic = 0;
			}

			output_revolute = (Joy_y / 100.0) * 60000.0;

			if (revolute_flag == 1 && output_revolute < 0) {
				output_revolute = 0;
			} else if (revolute_encoder.rads >= (2 * M_PI)
					&& output_revolute > 0) {
				output_revolute = 0;
			}

			if (button_reset == 1) {
				count_run = 1;
				current_state = STATE_RUNING;
				pointRunNeedsInit = 1;
				running_flang = 1;
			}

			if (button_run == 1 && button_reset_prev == 0) {
				count++;
				if (count > 0 && count <= 10) {
					registerFrame[18 + count * 2].U16 = ball_screw_pos * 10;
					registerFrame[19 + count * 2].U16 = (revolute_encoder.rads
							/ (2 * M_PI)) * 1800.0;
				} else {
					count = 1;
				}
			}

			pen_flag = 0;
			break;
		case STATE_RUNING:
			if (pointRunNeedsInit == 1) {
				// ต้องจ่ายค่ารอบเดียว
				target_position_revolute = (float) (registerFrame[19
						+ count_run * 2].U16 / 1800.0) * (2.0 * M_PI);
				target_position_prismatic =
						(registerFrame[18 + count_run * 2].U16 / 10);

				float abs_start_pris = (float) ball_screw_pos;
				float abs_goal_pris = target_position_prismatic;  // (mm)

				Trapezoidal_Init(&prisProfile, abs_start_pris, abs_goal_pris,
						550.0f, // v_max (mm/s)
						250.0f); // a_max (mm/s²)

				float abs_start_rev = (float) revolute_encoder.rads;
				float abs_goal_rev = target_position_revolute/* from registerFrame[65], converted to radians */;

				Trapezoidal_Init(&revProfile, abs_start_rev, abs_goal_rev, 2.0f, // v_max (rad/s)
						0.4f); // a_max (rad/s²)
				pointRunNeedsInit = 0;
			}

			if (!prisProfile.finished) {
				Trapezoidal_Update(&prisProfile, 0.001f);
			}
			if (!revProfile.finished) {
				Trapezoidal_Update(&revProfile, 0.001f);
			}

			Revolute_CasCadeControl();
			Prismatic_CasCadeControl();

			if (limit_r == 1 && limit_l_prev == 0) {
				output_prismatic = 0;
				QEI_Reset(&prismatic_encoder);
				QEIInit(&prismatic_encoder, &htim4, 8192, 1000, 65536);
			}

			if (revolute_flag == 1 && revolute_homed == 0) {
				output_revolute = 0;
				QEI_Reset(&revolute_encoder);
				QEIInit(&revolute_encoder, &htim3, 8192, 1000, 65536);
			}
			if (output_prismatic == 0 && output_revolute == 0
					&& prisProfile.finished && revProfile.finished) {
				pointRunNeedsInit = 1;
				count_run++;
				running_flang = 0;
				registerFrame[4].U16 = 0;
				registerFrame[5].U16 = 1;
				current_state = STATE_JOGGING;
			}
			pen_flag = 0;
			break;
		case STATE_POINT_MOVING:
			registerFrame[4].U16 = 1;
			registerFrame[5].U16 = 0;
			theta = (float) (registerFrame[65].U16);
			if (theta <= 1800) {
				target_position_revolute = (float) (registerFrame[65].U16
						/ 1800.0) * (2.0 * M_PI);
				target_position_prismatic = 300 - (registerFrame[64].U16 / 10);
			} else if (theta > 1800) {
				target_position_revolute = (float) (fabs(
						180 - registerFrame[65].U16 / 10.0));
				target_position_revolute = (float) (target_position_revolute
						/ 180.0) * (2.0 * M_PI);
				target_position_prismatic = mapf((registerFrame[64].U16 / 10),
						0, 300, 300, 600);
			}

			if (pointMoveNeedsInit) {
				float abs_start_pris = (float) ball_screw_pos;
				float abs_goal_pris = target_position_prismatic;

				Trapezoidal_Init(&prisProfile, abs_start_pris, abs_goal_pris,
						550.0f, 250.0f);

				float abs_start_rev = (float) revolute_encoder.rads;
				float abs_goal_rev = target_position_revolute;

				Trapezoidal_Init(&revProfile, abs_start_rev, abs_goal_rev, 2.0f, // v_max (rad/s)
						0.4f); // a_max (rad/s²)

				pointMoveNeedsInit = 0;
			}
			pen_flag = 0;
			break;
		case STATE_GO_TO_TARGET:

			if (!prisProfile.finished) {
				Trapezoidal_Update(&prisProfile, 0.001f);
			}
			if (!revProfile.finished) {
				Trapezoidal_Update(&revProfile, 0.001f);
			}

			Revolute_CasCadeControl();
			Prismatic_CasCadeControl();

			if (limit_r == 1 && limit_l_prev == 0) {
				output_prismatic = 0;
				QEI_Reset(&prismatic_encoder);
				QEIInit(&prismatic_encoder, &htim4, 8192, 1000, 65536);
			}

			if (revolute_flag == 1 && revolute_homed == 0) {
				output_revolute = 0;
				QEI_Reset(&revolute_encoder);
				QEIInit(&revolute_encoder, &htim3, 8192, 1000, 65536);
			}
			registerFrame[11].U16 = (int) (ball_screw_pos * 10);
			registerFrame[12].U16 = (int) (revolute_encoder.rads * (180 / M_PI)
					* 10);
			registerFrame[13].U16 = (int) (ball_screw_vel * 10);
			registerFrame[14].U16 = (int) (revolute_radps_lowpass * (180 / M_PI)
					* 10);
			registerFrame[15].U16 = (int) (prismatic_acceleration_lowpass * 10);
			registerFrame[16].U16 = (int) (((revolute_radps_lowpass
					- prev_revolute_vel) / 0.001) * 10);

			if (output_prismatic == 0 && output_revolute == 0
					&& prisProfile.finished && revProfile.finished) {
				registerFrame[1].U16 = STATUS_STOP;
			}
			pen_flag = 0;
			break;

		case STATE_STOPPING:
			registerFrame[10].U16 = STATUS_STOP;
			revolute_homed = 0;
			limit_l_prev = 0;
			output_revolute = 0;
			output_prismatic = 0;
			registerFrame[4].U16 = 0;
			registerFrame[5].U16 = 1;
			pen_flag = 0;
			break;

		case STATE_ERROR:
			//when emergency trick
			output_revolute = 0;
			output_prismatic = 0;
			registerFrame[4].U16 = 0;
			registerFrame[5].U16 = 1;
			pen_flag = 0;
			pain_flang = 0;
			break;
		}
		button_reset_prev = button_run;
	}
}
/* USER CODE END 4 */

/**
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void Error_Handler(void) {
	/* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */
	__disable_irq();
	while (1) {
	}
	/* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
